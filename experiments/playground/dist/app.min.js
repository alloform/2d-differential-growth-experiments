"use strict";

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
      o(t[i]);
    }

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    /** @module Bounds */
    var inside = require('./node_modules/point-in-polygon');
    /** Polygonal container for Paths that can constrain them to particular shapes */


    var Bounds = /*#__PURE__*/function () {
      /**
       * Create a new Bounds object
       * @param {object} p5 Reference to global instance of p5.js for drawing
       * @param {array} polygon Array of sequential points in the format of [polygon_n][x1][y1], ...  
       */
      function Bounds(p5, polygon) {
        _classCallCheck(this, Bounds);

        this.p5 = p5;
        this.polygon = polygon;
      }
      /**
       * Test if a given point is within this Bounds polygon
       * @param {array} point Coordinates of point to test ([x,y])
       * @returns {boolean}
       */


      _createClass(Bounds, [{
        key: "contains",
        value: function contains(point) {
          return inside(point, this.polygon);
        }
        /** Draws this Bounds polygon to the canvas */

      }, {
        key: "draw",
        value: function draw() {
          this.p5.beginShape();

          for (var i = 0; i < this.polygon.length; i++) {
            this.p5.vertex(this.polygon[i][0], this.polygon[i][1]);
          }

          this.p5.vertex(this.polygon[0][0], this.polygon[0][1]);
          this.p5.endShape();
        }
      }]);

      return Bounds;
    }();

    module.exports = Bounds;
  }, {
    "./node_modules/point-in-polygon": 8
  }],
  2: [function (require, module, exports) {
    /** @module Defaults */
    module.exports = {
      /**
       * Minimum distance between nodes. Used in attraction, pruning, and injection
       * @type {number}
       */
      MinDistance: 20,

      /**
       * Maximum distance between nodes before they are split
       * @type {number}
       */
      MaxDistance: 30,

      /**
       * Radius to search for nearby nodes for repulsion force 
       * @type {number}
       */
      RepulsionRadius: 20,

      /**
       * Maximum velocity at which a node can move per frame 
       * @type {number}
       */
      MaxVelocity: .1,

      /**
       * Maximum attraction force between connected nodes
       * @type {number}
       */
      AttractionForce: .001,

      /**
       * Maximum repulsion force between nearby nodes
       * @type {number}
       */
      RepulsionForce: 500,

      /**
       * Maximum alignment force between connected nodes
       * @type {number}
       */
      AlignmentForce: .001,

      /**
       * Interval (in ms) between call to node injection routine
       * @type {number}
       */
      NodeInjectionInterval: 100,

      /**
       * Show/hide circles for each node
       * @type {boolean}
       */
      DrawNodes: false,

      /**
       * Allow accumulation of path growth by disabling background repaints
       * @type {boolean}
       */
      TraceMode: false,

      /**
       * Turn on/off inverted colors
       * @type {boolean}
       */
      InvertedColors: false,

      /**
       * Turn on/off debug mode (per-edge colors)
       * @type {boolean}
       */
      DebugMode: false,

      /**
       * Turn on/off shape fills for closed paths
       * @type {boolean}
       */
      FillMode: false,

      /**
       * Turn on/off capturing and rendering of previous node positions to create a "tree ring" effect
       * @type {boolean}
       */
      DrawHistory: false,

      /**
       * Interval (in ms) between capture of paths for history effect
       * @type {number}
       */
      HistoryCaptureInterval: 1000,

      /**
       * Maximum number of previous paths to capture for history effect
       * @type {number}
       */
      MaxHistorySize: 10,

      /**
       * Turn on/off Brownian motion
       * @type {boolean}
       */
      UseBrownianMotion: true,

      /**
       * Amount to 'jiggle' nodes when Brownian motion is enabled
       * @type {number}
       */
      BrownianMotionRange: 0.01,

      /**
       * Draw all boundaries
       * @type {boolean}
       */
      ShowBounds: true
    };
  }, {}],
  3: [function (require, module, exports) {
    /** @module Node */
    var Vec2 = require('./node_modules/vec2'),
        Defaults = require('./Defaults');
    /** 
     * Single point (node) within a Path, whose only job is to manage it's position and movement towards new position. 
     * @extends Vec2
     */


    var Node = /*#__PURE__*/function (_Vec) {
      _inherits(Node, _Vec);

      var _super = _createSuper(Node);

      /**
       * Create a new Node object
       * @param {object} p5 Reference to global instance of p5.js for drawing 
       * @param {number} x Initial X coordinate
       * @param {number} y Initial Y coordinate
       * @param {object} [settings] Object of local override Settings to merge with Defaults
       * @param {boolean} [isFixed] Whether or not this Node is allowed to move
       * @param {number} [minDistance] Minimum distance this Node wants to be to nearby Nodes
       * @param {number} [repulsionRadius] Radius around Node that will affect movement of other Nodes
       */
      function Node(p5, x, y) {
        var _this2;

        var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Defaults;
        var isFixed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var minDistance = arguments.length > 5 ? arguments[5] : undefined;
        var repulsionRadius = arguments.length > 6 ? arguments[6] : undefined;

        _classCallCheck(this, Node);

        _this2 = _super.call(this, x, y);
        _this2.p5 = p5;
        _this2.isFixed = isFixed;
        _this2.settings = Object.assign({}, Defaults, settings);
        _this2.velocity = 0;
        _this2.nextPosition = new Vec2(x, y);
        _this2.minDistance = minDistance || settings.MinDistance;
        _this2.repulsionRadius = repulsionRadius || settings.RepulsionRadius;
        return _this2;
      }
      /** Moves Node by one "step */


      _createClass(Node, [{
        key: "iterate",
        value: function iterate() {
          if (!this.isFixed) {
            this.x = this.p5.lerp(this.x, this.nextPosition.x, this.settings.MaxVelocity);
            this.y = this.p5.lerp(this.y, this.nextPosition.y, this.settings.MaxVelocity);
          }
        }
        /** Draw this Node to the canvas */

      }, {
        key: "draw",
        value: function draw() {
          if (this.isFixed) {
            this.p5.ellipse(this.x, this.y, 20);
          } else {
            this.p5.ellipse(this.x, this.y, 5);
          }
        }
      }]);

      return Node;
    }(Vec2);

    module.exports = Node;
  }, {
    "./Defaults": 2,
    "./node_modules/vec2": 18
  }],
  4: [function (require, module, exports) {
    /** @module Path */
    var knn = require('./node_modules/rbush-knn'),
        Node = require('./Node'),
        Bounds = require('./Bounds'),
        Defaults = require('./Defaults');
    /** Manages a set of Nodes in a continuous, ordered data structure (an Array). */


    var Path = /*#__PURE__*/function () {
      /**
       * Create a new Path object
       * @param {object} p5 Reference to global p5.js instance
       * @param {array} nodes Array of initial Node objects to start with
       * @param {object} [settings] Object containing local override Settings to be merged with Defaults
       * @param {boolean} [isClosed] Whether this Path is closed (true) or open (false)
       * @param {object} [bounds] Bounds object that this Path must stay within
       * @param {object} [fillColor] Fill color object containing properties h, s, b, and a
       * @param {object} [strokeColor] Stroke color object containing properties h, s, b, and a
       * @param {object} [invertedFillColor] Fill color in "invert mode" containing properties h, s, b, and a
       * @param {object} [invertedStrokeColor] Stroke color in "invert mode" containing properties h, s, b, and a
       */
      function Path(p5, nodes) {
        var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;
        var isClosed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var bounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var fillColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var strokeColor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var invertedFillColor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };
        var invertedStrokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };

        _classCallCheck(this, Path);

        this.p5 = p5;
        this.nodes = nodes;
        this.isClosed = isClosed;
        this.settings = Object.assign({}, Defaults, settings);
        this.bounds = bounds;
        this.injectionMode = "RANDOM";
        this.lastNodeInjectTime = 0;
        this.nodeHistory = [];
        this.drawNodes = this.settings.DrawNodes;
        this.invertedColors = this.settings.InvertedColors;
        this.traceMode = this.settings.TraceMode;
        this.debugMode = this.settings.DebugMode;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.drawHistory = this.settings.DrawHistory;
        this.showBounds = this.settings.ShowBounds;
        this.fillColor = fillColor;
        this.strokeColor = strokeColor;
        this.invertedFillColor = invertedFillColor;
        this.invertedStrokeColor = invertedStrokeColor;
        this.currentFillColor = this.fillColor;
        this.currentStrokeColor = this.strokeColor;

        if (this.invertedColors) {
          this.currentFillColor = this.invertedFillColor;
          this.currentStrokeColor = this.invertedStrokeColor;
        }
      }
      /**
       * Run one "tick" of the simulation
       * @param {object} tree Reference to the appropriate R-tree index that this Path belongs to (see World)
       */


      _createClass(Path, [{
        key: "iterate",
        value: function iterate(tree) {
          var _iterator2 = _createForOfIteratorHelper(this.nodes.entries()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = _slicedToArray(_step2.value, 2),
                  index = _step2$value[0],
                  node = _step2$value[1];

              // Apply Brownian motion to realistically 'jiggle' nodes
              if (this.useBrownianMotion) {
                this.applyBrownianMotion(index);
              } // Move towards neighbors (attraction), if there is space to move


              this.applyAttraction(index); // Move away from any nodes that are too close (repulsion)

              this.applyRepulsion(index, tree); // Align with neighbors

              this.applyAlignment(index); // Apply boundaries

              this.applyBounds(index); // Move towards next position

              node.iterate();
            } // Split any edges that have become too long

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          this.splitEdges(); // Remove any nodes that are too close to other nodes

          this.pruneNodes(); // Inject a new node to introduce asymmetry every so often

          if (this.p5.millis() - this.lastNodeInjectTime >= this.settings.NodeInjectionInterval) {
            this.injectNode();
            this.lastNodeInjectTime = this.p5.millis();
          }
        }
        /**
         * For the Node wit the provided index, simulate the small random motions that real microscopic particles experience from collisions with fast-moving molecules
         * @param {number} index Index of Node to apply forces to
         */

      }, {
        key: "applyBrownianMotion",
        value: function applyBrownianMotion(index) {
          this.nodes[index].x += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
          this.nodes[index].y += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
        }
        /**
         * Move the Node with the provided index closer to it's connected neighbor Nodes
         * @param {number} index Index of Node to apply forces to
         */

      }, {
        key: "applyAttraction",
        value: function applyAttraction(index) {
          var distance, leastMinDistance;
          var connectedNodes = this.getConnectedNodes(index); // Move towards next node, if there is one

          if (connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.nextNode);
            leastMinDistance = Math.min(this.nodes[index].minDistance, connectedNodes.nextNode.minDistance);

            if (distance > leastMinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.nextNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.nextNode.y, this.settings.AttractionForce);
            }
          } // Move towards previous node, if there is one


          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.previousNode);
            leastMinDistance = Math.min(this.nodes[index].minDistance, connectedNodes.previousNode.minDistance);

            if (distance > leastMinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.previousNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.previousNode.y, this.settings.AttractionForce);
            }
          }
        }
        /**
         * Move the referenced Node (by index) away from all other nearby Nodes within the appropriate R-tree index (tree), within a pre-defined radius
         * @param {number} index Index of Node to apply forces to
         * @param {object} tree Reference to the appropriate R-tree index that this Path belongs to (see World)
         */

      }, {
        key: "applyRepulsion",
        value: function applyRepulsion(index, tree) {
          // Perform knn search to find all neighbors within certain radius
          var neighbors = knn(tree, this.nodes[index].x, this.nodes[index].y, undefined, undefined, this.nodes[index].repulsionRadius * this.nodes[index].repulsionRadius); // radius must be squared as per https://github.com/mourner/rbush-knn/issues/13
          // Move this node away from all nearby neighbors
          // TODO: Make this proportional to distance?

          var _iterator3 = _createForOfIteratorHelper(neighbors),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var node = _step3.value;
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].x, node.x, -this.settings.RepulsionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].y, node.y, -this.settings.RepulsionForce);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
        /**
         * Move the referenced Node (by index) towards the midpoint of it's connected neighbor Nodes in an effort to minimize curvature
         * @param {number} index Index of Node to apply forces to
         */

      }, {
        key: "applyAlignment",
        value: function applyAlignment(index) {
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            // Find the midpoint between the neighbors of this node
            var midpoint = this.getMidpointNode(connectedNodes.previousNode, connectedNodes.nextNode); // Move this point towards this midpoint

            this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, midpoint.x, this.settings.AlignmentForce);
            this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, midpoint.y, this.settings.AlignmentForce);
          }
        }
        /** Search for edges that are too long and inject a new Node to split them up */

      }, {
        key: "splitEdges",
        value: function splitEdges() {
          var _iterator4 = _createForOfIteratorHelper(this.nodes.entries()),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _slicedToArray(_step4.value, 2),
                  index = _step4$value[0],
                  node = _step4$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) >= this.settings.MaxDistance) {
                var midpointNode = this.getMidpointNode(node, connectedNodes.previousNode); // Inject the new midpoint node into the global list

                if (index == 0) {
                  this.nodes.splice(this.nodes.length, 0, midpointNode);
                } else {
                  this.nodes.splice(index, 0, midpointNode);
                }
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
        /** Remove Nodes that are too close to their neighbors to minimize "pinching" */

      }, {
        key: "pruneNodes",
        value: function pruneNodes() {
          var _iterator5 = _createForOfIteratorHelper(this.nodes.entries()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  index = _step5$value[0],
                  node = _step5$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) < this.settings.MinDistance) {
                if (index == 0) {
                  if (!this.nodes[this.nodes.length - 1].isFixed) {
                    this.nodes.splice(this.nodes.length - 1, 1);
                  }
                } else {
                  if (!this.nodes[index - 1].isFixed) {
                    this.nodes.splice(index - 1, 1);
                  }
                }
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
        /** Insert a new Node using the current injection method */

      }, {
        key: "injectNode",
        value: function injectNode() {
          switch (this.injectionMode) {
            case "RANDOM":
              this.injectRandomNode();
              break;

            case "CURVATURE":
              this.injectNodeByCurvature();
              break;
          }
        }
        /** Insert a new Node in a random location along the Path, if there is space for it */

      }, {
        key: "injectRandomNode",
        value: function injectRandomNode() {
          // Choose two connected nodes at random
          var index = parseInt(this.p5.random(1, this.nodes.length));
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && this.nodes[index].distance(connectedNodes.previousNode) > this.settings.MinDistance) {
            // Create a new node in the middle
            var midpointNode = this.getMidpointNode(this.nodes[index], connectedNodes.previousNode); // Splice new node into array

            this.nodes.splice(index, 0, midpointNode);
          }
        }
        /** Insert a new Node in an area where curvature is high */

      }, {
        key: "injectNodeByCurvature",
        value: function injectNodeByCurvature() {
          var _iterator6 = _createForOfIteratorHelper(this.nodes.entries()),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _step6$value = _slicedToArray(_step6.value, 2),
                  index = _step6$value[0],
                  node = _step6$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode == undefined || connectedNodes.nextNode == undefined) {
                continue;
              } // Find angle between adjacent nodes


              var n = connectedNodes.nextNode.y - connectedNodes.previousNode.y;
              var d = connectedNodes.nextNode.x - connectedNodes.previousNode.x;
              var angle = Math.round(Math.abs(Math.atan(n / d))); // // If angle is below a certain angle (high curvature), replace the current node with two nodes

              if (angle > 20) {
                var previousMidpointNode = this.getMidpointNode(node, connectedNodes.previousNode);
                var nextMidpointNode = this.getMidpointNode(node, connectedNodes.nextNode); // // Replace this node with the two new nodes

                if (index == 0) {
                  this.nodes.splice(this.nodes.length - 1, 0, previousMidpointNode);
                  this.nodes.splice(0, 0, nextMidpointNode);
                } else {
                  this.nodes.splice(index, 1, previousMidpointNode, nextMidpointNode);
                }
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
        /**
         * Do not allow the referenced Node (by index) to leave the interior of the assigned Bounds polygon
         * @param {number} index Index of Node to apply force to
         */

      }, {
        key: "applyBounds",
        value: function applyBounds(index) {
          if (this.bounds != undefined && this.bounds instanceof Bounds && !this.bounds.contains([this.nodes[index].x, this.nodes[index].y])) {
            this.nodes[index].isFixed = true;
          }
        }
        /**
         * For a given Node, find a return it's immediate connected neighbor Nodes
         * @param {number} index Index of Node to retrieve neighbors of
         * @returns {object} References to previous and next nodes, if they exist. Will always return a value for at least one.
         */

      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(index) {
          var previousNode, nextNode; // Find previous node, if there is one

          if (index == 0 && this.isClosed) {
            previousNode = this.nodes[this.nodes.length - 1];
          } else if (index >= 1) {
            previousNode = this.nodes[index - 1];
          } // Find next node, if there is one


          if (index == this.nodes.length - 1 && this.isClosed) {
            nextNode = this.nodes[0];
          } else if (index <= this.nodes.length - 1) {
            nextNode = this.nodes[index + 1];
          }

          return {
            previousNode: previousNode,
            nextNode: nextNode
          };
        }
        /**
         * Create and return a Node exactly halfway between the two provided Nodes
         * @param {object} node1 First node
         * @param {object} node2 Second node
         * @param {boolean} [fixed] Whether this new Node should be fixed or not
         * @returns {object} New Node object
         */

      }, {
        key: "getMidpointNode",
        value: function getMidpointNode(node1, node2) {
          var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return new Node(this.p5, (node1.x + node2.x) / 2, (node1.y + node2.y) / 2, this.settings, fixed);
        }
        /** Draw this Path to the canvas using current object visibility settings */

      }, {
        key: "draw",
        value: function draw() {
          // Draw all the previous paths saved to the history array
          if (this.drawHistory) {
            this.drawPreviousEdges();
          } // Draw bounds


          if (this.showBounds && this.bounds != undefined && this.bounds instanceof Bounds) {
            this.drawBounds();
          } // Set shape fill 


          if (this.fillMode && this.isClosed) {
            this.p5.fill(this.currentFillColor.h, this.currentFillColor.s, this.currentFillColor.b, this.currentFillColor.a);
          } else {
            this.p5.noFill();
          } // Set stroke color


          this.p5.stroke(this.currentStrokeColor.h, this.currentStrokeColor.s, this.currentStrokeColor.b, this.currentStrokeColor.a); // Draw current edges

          this.drawCurrentEdges(); // Draw all nodes

          if (this.drawNodes) {
            this.drawCurrentNodes();
          }
        }
        /** Draw the current edges (leading edge) of the path */

      }, {
        key: "drawCurrentEdges",
        value: function drawCurrentEdges() {
          this.drawEdges(this.nodes);
        }
        /** Draw all previous edges of the path saved to history array */

      }, {
        key: "drawPreviousEdges",
        value: function drawPreviousEdges() {
          var _iterator7 = _createForOfIteratorHelper(this.nodeHistory.entries()),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var _step7$value = _slicedToArray(_step7.value, 2),
                  index = _step7$value[0],
                  nodes = _step7$value[1];

              this.p5.stroke(this.currentStrokeColor.h, this.currentStrokeColor.s, this.currentStrokeColor.b, index * 30);
              this.drawEdges(nodes);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }
        /**
         * Draw edges for a given set of nodes - can be either the current or previous nodes
         * @param {array} nodes Array of Node objects
         */

      }, {
        key: "drawEdges",
        value: function drawEdges(nodes) {
          // Begin capturing vertices
          if (!this.debugMode) {
            this.p5.beginShape();
          } // Create vertices or lines (if debug mode)


          for (var i = 0; i < nodes.length; i++) {
            if (!this.debugMode) {
              this.p5.vertex(nodes[i].x, nodes[i].y);
            } else {
              // In debug mode each line has a unique stroke color, which isn't possible with begin/endShape(). Instead we'll use line()
              if (i > 0) {
                if (!this.traceMode) {
                  this.p5.stroke(this.p5.map(i, 0, nodes.length - 1, 0, 255, true), 255, 255, 255);
                } else {
                  this.p5.stroke(this.p5.map(i, 0, nodes.length - 1, 0, 255, true), 255, 255, 2);
                }

                this.p5.line(nodes[i - 1].x, nodes[i - 1].y, nodes[i].x, nodes[i].y);
              }
            }
          } // For closed paths, connect the last and first nodes


          if (this.isClosed) {
            if (!this.debugMode) {
              this.p5.vertex(nodes[0].x, nodes[0].y);
            } else {
              this.p5.line(nodes[nodes.length - 1].x, nodes[nodes.length - 1].y, nodes[0].x, nodes[0].y);
            }
          } // Stop capturing vertices


          if (!this.debugMode) {
            this.p5.endShape();
          }
        }
        /** Draw circles for every node */

      }, {
        key: "drawCurrentNodes",
        value: function drawCurrentNodes() {
          this.p5.noStroke();

          if (!this.invertedColors) {
            this.p5.fill(0);
          } else {
            this.p5.fill(255);
          }

          var _iterator8 = _createForOfIteratorHelper(this.nodes.entries()),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var _step8$value = _slicedToArray(_step8.value, 2),
                  index = _step8$value[0],
                  node = _step8$value[1];

              if (this.debugMode) {
                this.p5.fill(this.p5.map(index, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
              }

              node.draw();
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
        /** Draw boundary shape(s) */

      }, {
        key: "drawBounds",
        value: function drawBounds() {
          if (!this.invertedColors) {
            this.p5.stroke(200);
          } else {
            this.p5.stroke(100);
          }

          this.p5.noFill();
          this.bounds.draw();
        }
        /** Take a snapshot of the current nodes by saving a dereferenced clone of them to the history array */

      }, {
        key: "addToHistory",
        value: function addToHistory() {
          if (this.nodeHistory.length == this.settings.MaxHistorySize) {
            this.nodeHistory.shift();
          }

          this.nodeHistory.push(Object.assign([], JSON.parse(JSON.stringify(this.nodes))));
        }
        /**
         * Move this entire Path by a certain amount by moving all of it's Nodes
         * @param {number} xOffset Distance on X axis to move Path
         * @param {number} yOffset Distance on Y axis to move Path
         */

      }, {
        key: "moveTo",
        value: function moveTo(xOffset, yOffset) {
          var _iterator9 = _createForOfIteratorHelper(this.nodes),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var node = _step9.value;
              node.x += xOffset;
              node.y += yOffset;
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
        /**
         * Scale (multiply) all Nodes by the provided factor
         * @param {number} factor Factor to multiple all Nodes' coordinates by
         */

      }, {
        key: "scale",
        value: function scale(factor) {
          var _iterator10 = _createForOfIteratorHelper(this.nodes),
              _step10;

          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var node = _step10.value;
              node.x *= factor;
              node.y *= factor;
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
        }
        /**
         * Insert a new Node object from outside of this class
         * @param {object} node Node object to insert
         */

      }, {
        key: "addNode",
        value: function addNode(node) {
          this.nodes.push(node);
        }
        /**
         * Return a raw 2D array of all Node coordinates. Useful for creating Bounds objects.
         * @returns {array} Array of all Node coordinates in the format of [polygon_n][x1][y1], ...
         */

      }, {
        key: "toArray",
        value: function toArray() {
          var polygon = [];

          var _iterator11 = _createForOfIteratorHelper(this.nodes),
              _step11;

          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var node = _step11.value;
              polygon.push([node.x, node.y]);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }

          return polygon;
        }
        /**
         * Get the current state of "trace mode" flag
         * @returns {boolean} Current state of "trace mode" flag
         */

      }, {
        key: "getTraceMode",
        value: function getTraceMode() {
          return this.traceMode;
        }
        /**
         * Get the current state of the "invert mode" flag
         * @returns {boolean} Current state of the "invert mode" flag
         */

      }, {
        key: "getInvertedColors",
        value: function getInvertedColors() {
          return this.invertedColors;
        }
        /**
         * Sets the minimum distance that each Node wants to be from it's neighboring Nodes
         * @param {number} minDistance 
         */

      }, {
        key: "setMinDistance",
        value: function setMinDistance(minDistance) {
          this.settings.MinDistance = minDistance;

          var _iterator12 = _createForOfIteratorHelper(this.nodes),
              _step12;

          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var node = _step12.value;
              node.minDistance = minDistance;
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        }
        /**
         * Sets the maximum distance an edge can be before it is split
         * @param {number} maxDistance 
         */

      }, {
        key: "setMaxDistance",
        value: function setMaxDistance(maxDistance) {
          this.settings.MaxDistance = maxDistance;

          var _iterator13 = _createForOfIteratorHelper(this.nodes),
              _step13;

          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var node = _step13.value;
              node.maxDistance = maxDistance;
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
        }
        /**
         * Sets the radius around each Node that it can affect other Nodes
         * @param {number} repulsionRadius 
         */

      }, {
        key: "setRepulsionRadius",
        value: function setRepulsionRadius(repulsionRadius) {
          this.settings.RepulsionRadius = repulsionRadius;

          var _iterator14 = _createForOfIteratorHelper(this.nodes),
              _step14;

          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var node = _step14.value;
              node.repulsionRadius = repulsionRadius;
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
        }
        /**
         * Sets the state of the "trace mode" flag
         * @param {boolean} state New state for "trace mode" flag
         */

      }, {
        key: "setTraceMode",
        value: function setTraceMode(state) {
          this.traceMode = state;

          if (!this.traceMode) {
            this.currentFillColor.a = 255;
            this.currentStrokeColor.a = 255;
          } else {
            this.currentFillColor.a = 255;
            this.currentStrokeColor.a = 255;
          }
        }
        /**
         * Sets the state of the "invert mode" flag
         * @param {boolean} state New state for "invert mode" flag
         */

      }, {
        key: "setInvertedColors",
        value: function setInvertedColors(state) {
          this.invertedColors = state;

          if (!this.invertedColors) {
            this.currentFillColor = this.fillColor;
            this.currentStrokeColor = this.strokeColor;
          } else {
            this.currentFillColor = this.invertedFillColor;
            this.currentStrokeColor = this.invertedStrokeColor;
          } // Reapply the current trace mode state to make sure opacity is adjusted when colors are inverted


          this.setTraceMode(this.traceMode);
        }
        /**
         * Set the Bounds object that this Path must stay within
         * @param {object} bounds Bounds object that this Path must stay within
         */

      }, {
        key: "setBounds",
        value: function setBounds(bounds) {
          this.bounds = bounds;
        }
        /** Toggle the current state of the "trace mode" flag */

      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.setTraceMode(!this.getTraceMode());
        }
        /** Toggle the current state of the "invert mode" flag */

      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.setInvertedColors(!this.getInvertedColors());
        }
      }]);

      return Path;
    }();

    module.exports = Path;
  }, {
    "./Bounds": 1,
    "./Defaults": 2,
    "./Node": 3,
    "./node_modules/rbush-knn": 10
  }],
  5: [function (require, module, exports) {
    /** @module SVGLoader */
    var Node = require('./Node'),
        Path = require('./Path'),
        Defaults = require('./Defaults'),
        _require = require('./node_modules/svg-pathdata'),
        SVGPathData = _require.SVGPathData;
    /** Utility class to load an external SVG file and produce Path(s) */


    var SVGLoader = /*#__PURE__*/function () {
      function SVGLoader() {
        _classCallCheck(this, SVGLoader);
      }
      /**
       * Kick of loading of an SVG document embedded within a DOM element with the provided ID
       * @param {object} p5 Reference to the global instance of p5.js
       * @param {string} id ID attribute of the DOM node to load SVG data from
       * @param {object} settings Object containing local override Settings to merge with Defaults
       * @returns {array} See `load()`
       */


      _createClass(SVGLoader, null, [{
        key: "loadFromObject",
        value: function loadFromObject(p5, id) {
          var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;
          return this.load(p5, document.getElementById(id), settings);
        }
        /**
         * Extract path data from the provided SVG node and produce a set of Path objects with Nodes
         * @param {object} p5 Reference to the global instance of p5.js
         * @param {node} svgNode SVG DOM node to load data from
         * @param {object} settings Object containing local override Settings to merge with Defaults
         */

      }, {
        key: "load",
        value: function load(p5, svgNode) {
          var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;
          this.settings = Object.assign({}, Defaults, settings);
          var inputPaths = svgNode.querySelectorAll('path'),
              currentPath = new Path(p5, [], this.settings, true),
              paths = []; // Scrape all points from all points, and record breakpoints

          var _iterator15 = _createForOfIteratorHelper(inputPaths),
              _step15;

          try {
            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
              var inputPath = _step15.value;
              var pathData = new SVGPathData(inputPath.getAttribute('d'));
              var previousCoords = {
                x: 0,
                y: 0
              };

              var _iterator16 = _createForOfIteratorHelper(pathData.commands.entries()),
                  _step16;

              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  var _step16$value = _slicedToArray(_step16.value, 2),
                      index = _step16$value[0],
                      command = _step16$value[1];

                  switch (command.type) {
                    // Move ('M') and line ('L') commands have both X and Y
                    case SVGPathData.MOVE_TO:
                    case SVGPathData.LINE_TO:
                      currentPath.addNode(new Node(p5, command.x, command.y, this.settings));
                      break;
                    // Horizontal line ('H') commands only have X, using previous command's Y

                    case SVGPathData.HORIZ_LINE_TO:
                      currentPath.addNode(new Node(p5, command.x, previousCoords.y, this.settings));
                      break;
                    // Vertical line ('V') commands only have Y, using previous command's X

                    case SVGPathData.VERT_LINE_TO:
                      currentPath.addNode(new Node(p5, previousCoords.x, command.y, this.settings));
                      break;
                    // ClosePath ('Z') commands are a naive indication that the current path can be processed and added to the world

                    case SVGPathData.CLOSE_PATH:
                      // Capture path in return object
                      paths.push(currentPath); // Set up a new empty Path for the next loop iterations

                      currentPath = new Path(p5, [], this.settings, true);
                      currentPath.setInvertedColors(true);
                      break;
                  } // Unclosed paths never have CLOSE_PATH commands, so wrap up the current path when we're at the end of the path and have not found the command


                  if (index == pathData.commands.length - 1 && command.type != SVGPathData.CLOSE_PATH) {
                    var firstNode = currentPath.nodes[0],
                        lastNode = currentPath.nodes[currentPath.nodes.length - 1]; // Automatically close the path if the first and last nodes are effectively the same, even if a CLOSE_PATH command doesn't exist

                    if (lastNode.distance(firstNode) < .1) {
                      currentPath.isClosed = true;
                    } else {
                      currentPath.isClosed = false;
                    }

                    paths.push(currentPath);
                    currentPath = new Path(p5, [], this.settings, true);
                  } // Capture X coordinate, if there was one


                  if (command.hasOwnProperty('x')) {
                    previousCoords.x = command.x;
                  } // Capture Y coordinate, if there was one


                  if (command.hasOwnProperty('y')) {
                    previousCoords.y = command.y;
                  }
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
            }
          } catch (err) {
            _iterator15.e(err);
          } finally {
            _iterator15.f();
          }

          return paths;
        }
      }]);

      return SVGLoader;
    }();

    module.exports = SVGLoader;
  }, {
    "./Defaults": 2,
    "./Node": 3,
    "./Path": 4,
    "./node_modules/svg-pathdata": 12
  }],
  6: [function (require, module, exports) {
    /** @module World */
    var rbush = require('./node_modules/rbush'),
        toPath = require('./node_modules/svg-points/').toPath,
        saveAs = require('./node_modules/file-saver').saveAs,
        Defaults = require('./Defaults');
    /** Manages a set of Paths and provides some global control mechanisms, such as pausing the simulation. */


    var World = /*#__PURE__*/function () {
      /**
       * Create a new World object
       * @param {object} p5 Reference to global p5.js instance
       * @param {object} [settings] Object containing local override Settings to be merged with Defaults
       * @param {array} [paths] Array of Path objects that belong to this World
       */
      function World(p5) {
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Defaults;
        var paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        _classCallCheck(this, World);

        this.p5 = p5;
        this.paths = paths;
        this.paused = false;
        this.settings = Object.assign({}, Defaults, settings);
        this.traceMode = this.settings.TraceMode;
        this.drawNodes = this.settings.DrawNodes;
        this.debugMode = this.settings.DebugMode;
        this.invertedColors = this.settings.InvertedColors;
        this.fillMode = this.settings.FillMode;
        this.drawHistory = this.settings.DrawHistory;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.showBounds = this.settings.ShowBounds;
        this.tree = rbush(9, ['.x', '.y', '.x', '.y']); // use custom accessor strings per https://github.com/mourner/rbush#data-format

        this.buildTree(); // Begin capturing path history

        var _this = this;

        setInterval(function () {
          _this.addToHistory();
        }, this.settings.HistoryCaptureInterval);
      }
      /** Run a single "tick" of the simulation by iterating on all Paths */


      _createClass(World, [{
        key: "iterate",
        value: function iterate() {
          this.prunePaths();
          this.buildTree();

          if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0 && !this.paused) {
            var _iterator17 = _createForOfIteratorHelper(this.paths),
                _step17;

            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var path = _step17.value;
                path.iterate(this.tree);
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }
          }
        }
        /** Draw the background and all Paths */

      }, {
        key: "draw",
        value: function draw() {
          if (!this.traceMode) {
            this.drawBackground();
          }

          var _iterator18 = _createForOfIteratorHelper(this.paths),
              _step18;

          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var path = _step18.value;
              path.draw();
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }
        }
        /** Draw the background to the canvas */

      }, {
        key: "drawBackground",
        value: function drawBackground() {
          if (!this.invertedColors) {
            this.p5.background(255);
          } else {
            this.p5.background(0);
          }
        }
        /** Build an R-tree spatial index with all Nodes of all Paths in this World */

      }, {
        key: "buildTree",
        value: function buildTree() {
          this.tree.clear();

          var _iterator19 = _createForOfIteratorHelper(this.paths),
              _step19;

          try {
            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
              var path = _step19.value;
              this.tree.load(path.nodes);
            }
          } catch (err) {
            _iterator19.e(err);
          } finally {
            _iterator19.f();
          }
        }
        /**
         * Add a new Path to the World from outside this class
         * @param {object} path Path object to add to this World
         */

      }, {
        key: "addPath",
        value: function addPath(path) {
          // Cascade all current World settings to new path
          path.drawNodes = this.drawNodes;
          path.debugMode = this.debugMode;
          path.fillMode = this.fillMode;
          path.useBrownianMotion = this.useBrownianMotion;
          path.setInvertedColors(this.invertedColors);
          path.setTraceMode(this.traceMode);
          this.paths.push(path);
        }
        /**
         * Add multiple Path objects to this World
         * @param {array} paths
         */

      }, {
        key: "addPaths",
        value: function addPaths(paths) {
          var _iterator20 = _createForOfIteratorHelper(paths),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var path = _step20.value;
              this.addPath(path);
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
        }
        /** Add another snapshot to each Path */

      }, {
        key: "addToHistory",
        value: function addToHistory() {
          if (!this.paused) {
            var _iterator21 = _createForOfIteratorHelper(this.paths),
                _step21;

            try {
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                var path = _step21.value;
                path.addToHistory();
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }
          }
        }
        /** Remove any Paths that have gotten too small */

      }, {
        key: "prunePaths",
        value: function prunePaths() {
          for (var i = 0; i < this.paths.length; i++) {
            if (this.paths[i].nodes.length <= 1) {
              this.paths.splice(i, 1);
            }
          }
        }
        /** Generate an SVG file using the current canvas contents and open up a download prompt on the user's machine */

      }, {
        key: "export",
        value: function _export() {
          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
          svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
          svg.setAttribute('width', window.innerWidth);
          svg.setAttribute('height', window.innerHeight);
          svg.setAttribute('viewBox', '0 0 ' + window.innerWidth + ' ' + window.innerHeight); // Add a <path> node for every Path in this World

          var _iterator22 = _createForOfIteratorHelper(this.paths),
              _step22;

          try {
            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
              var path = _step22.value;

              // If history is enabled, create a new <path> node for each snapshot
              if (this.drawHistory) {
                var _iterator23 = _createForOfIteratorHelper(path.nodeHistory),
                    _step23;

                try {
                  for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                    var nodes = _step23.value;
                    svg.appendChild(this.createPathElFromNodes(nodes, path.isClosed));
                  }
                } catch (err) {
                  _iterator23.e(err);
                } finally {
                  _iterator23.f();
                }
              }

              svg.appendChild(this.createPathElFromNodes(path.nodes), path.isClosed);
            } // Force download of SVG based on https://jsfiddle.net/ch77e7yh/1

          } catch (err) {
            _iterator22.e(err);
          } finally {
            _iterator22.f();
          }

          var svgDoctype = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>';
          var serializedSvg = new XMLSerializer().serializeToString(svg);
          var blob = new Blob([svgDoctype, serializedSvg], {
            type: 'image/svg+xml;'
          });
          saveAs(blob, 'differential-growth-' + Date.now() + '.svg');
        }
        /**
         * Create a new SVG path element from a provided set of Node objects
         * @param {array} nodes Array of Node objects
         * @param {boolean} isClosed Whether this path should be closed (true) or open (false)
         * @returns SVG path DOM node with a `d` attribute generated from the provided Nodes array.
         */

      }, {
        key: "createPathElFromNodes",
        value: function createPathElFromNodes(nodes, isClosed) {
          var pointsString = '';

          var _iterator24 = _createForOfIteratorHelper(nodes.entries()),
              _step24;

          try {
            for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
              var _step24$value = _slicedToArray(_step24.value, 2),
                  index = _step24$value[0],
                  node = _step24$value[1];

              pointsString += node.x + ',' + node.y;

              if (index < nodes.length - 1) {
                pointsString += ' ';
              }
            }
          } catch (err) {
            _iterator24.e(err);
          } finally {
            _iterator24.f();
          }

          var d = toPath({
            type: 'polyline',
            points: pointsString
          });

          if (isClosed) {
            d += ' Z';
          }

          var pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          pathEl.setAttribute('d', d);
          pathEl.setAttribute('style', 'fill: none; stroke: black; stroke-width: 1');
          return pathEl;
        }
        /** Remove all Paths from this World */

      }, {
        key: "clearPaths",
        value: function clearPaths() {
          this.paths = [];
        }
        /** Pause the simulation */

      }, {
        key: "pause",
        value: function pause() {
          this.paused = true;
        }
        /** Unpause the simulation */

      }, {
        key: "unpause",
        value: function unpause() {
          this.paused = false;
        }
        /**
         * Get the current state of the Nodes visibility flag
         * @returns {boolean} Current state of Node visibility flag
         */

      }, {
        key: "getDrawNodes",
        value: function getDrawNodes() {
          return this.drawNodes;
        }
        /**
         * Get the current state of the debug mode flag
         * @returns {boolean} Current state of debug mode flag
         */

      }, {
        key: "getDebugMode",
        value: function getDebugMode() {
          return this.debugMode;
        }
        /**
         * Get the current state of the fill mode flag
         * @returns {boolean} Current state of the fill mode flag
         */

      }, {
        key: "getFillMode",
        value: function getFillMode() {
          return this.fillMode;
        }
        /**
         * Get the current state of the history effect visibility flag
         * @returns {boolean} Current state of the history effect visibility flag
         */

      }, {
        key: "getDrawHistory",
        value: function getDrawHistory() {
          return this.drawHistory;
        }
        /**
         * Get the current state of the Bounds visibility flag
         * @returns {boolean} Current state of the Bounds visibility flag
         */

      }, {
        key: "getDrawBounds",
        value: function getDrawBounds() {
          return this.showBounds;
        }
        /**
         * Set the minimum distance that each Node wants to be from it's connected neighbors
         * @param {number} minDistance Distance that each Node wants to be from it's neighbors
         */

      }, {
        key: "setMinDistance",
        value: function setMinDistance(minDistance) {
          this.settings.MinDistance = minDistance;

          var _iterator25 = _createForOfIteratorHelper(this.paths),
              _step25;

          try {
            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
              var path = _step25.value;
              path.setMinDistance(minDistance);
            }
          } catch (err) {
            _iterator25.e(err);
          } finally {
            _iterator25.f();
          }
        }
        /**
         * Set the maximum distance an edge can be before it is split
         * @param {number} maxDistance Distance between each Node
         */

      }, {
        key: "setMaxDistance",
        value: function setMaxDistance(maxDistance) {
          this.settings.MaxDistance = maxDistance;

          var _iterator26 = _createForOfIteratorHelper(this.paths),
              _step26;

          try {
            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
              var path = _step26.value;
              path.setMaxDistance(maxDistance);
            }
          } catch (err) {
            _iterator26.e(err);
          } finally {
            _iterator26.f();
          }
        }
        /**
         * Set the distance around each Node that it can affect other Nodes through repulsion
         * @param {number} repulsionRadius Distance around each Node
         */

      }, {
        key: "setRepulsionRadius",
        value: function setRepulsionRadius(repulsionRadius) {
          this.settings.RepulsionRadius = repulsionRadius;

          var _iterator27 = _createForOfIteratorHelper(this.paths),
              _step27;

          try {
            for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
              var path = _step27.value;
              path.setRepulsionRadius(repulsionRadius);
            }
          } catch (err) {
            _iterator27.e(err);
          } finally {
            _iterator27.f();
          }
        }
        /**
         * Set the force scalar that is used when Nodes pull each other closer
         * @param {number} attractionForce Scalar value used for attraction force
         */

      }, {
        key: "setAttractionForce",
        value: function setAttractionForce(attractionForce) {
          this.settings.AttractionForce = attractionForce;

          var _iterator28 = _createForOfIteratorHelper(this.paths),
              _step28;

          try {
            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
              var path = _step28.value;
              path.setAttractionForce(attractionForce);
            }
          } catch (err) {
            _iterator28.e(err);
          } finally {
            _iterator28.f();
          }
        }
        /**
         * Set the force scalar that is used when Nodes are pushing others away
         * @param {number} repulsionForce Scalar value used for repulsion force
         */

      }, {
        key: "setRepulsionForce",
        value: function setRepulsionForce(repulsionForce) {
          this.settings.RepulsionForce = repulsionForce;

          var _iterator29 = _createForOfIteratorHelper(this.paths),
              _step29;

          try {
            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
              var path = _step29.value;
              path.setRepulsionForce(repulsionForce);
            }
          } catch (err) {
            _iterator29.e(err);
          } finally {
            _iterator29.f();
          }
        }
        /**
         * Set the force scalar that is used when Nodes trying to align with their neighbors to reduce curvature
         * @param {number} alignmentForce Scalar value used for alignment force
         */

      }, {
        key: "setAlignmentForce",
        value: function setAlignmentForce(alignmentForce) {
          this.settings.AlignmentForce = alignmentForce;

          var _iterator30 = _createForOfIteratorHelper(this.paths),
              _step30;

          try {
            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
              var path = _step30.value;
              path.setAlignmentForce(alignmentForce);
            }
          } catch (err) {
            _iterator30.e(err);
          } finally {
            _iterator30.f();
          }
        }
        /**
         * Set the state of the Node visibility flag
         * @param {boolean} state Next state for the Node visibility flag
         */

      }, {
        key: "setDrawNodes",
        value: function setDrawNodes(state) {
          this.drawBackground();

          var _iterator31 = _createForOfIteratorHelper(this.paths),
              _step31;

          try {
            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
              var path = _step31.value;
              path.drawNodes = state;
              path.draw();
            }
          } catch (err) {
            _iterator31.e(err);
          } finally {
            _iterator31.f();
          }

          this.drawNodes = state;
          this.settings.DrawNodes = state;
        }
        /**
         * Set the state of the "debug mode" flag
         * @param {boolean} state Next state for the "debug mode" flag
         */

      }, {
        key: "setDebugMode",
        value: function setDebugMode(state) {
          this.drawBackground();

          var _iterator32 = _createForOfIteratorHelper(this.paths),
              _step32;

          try {
            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
              var path = _step32.value;
              path.debugMode = state;
              path.draw();
            }
          } catch (err) {
            _iterator32.e(err);
          } finally {
            _iterator32.f();
          }

          this.debugMode = state;
          this.settings.DebugMode = state;
        }
        /**
         * Set the state of the "fill mode" flag
         * @param {boolean} state Next state for the "fill mode" flag
         */

      }, {
        key: "setFillMode",
        value: function setFillMode(state) {
          this.drawBackground();

          var _iterator33 = _createForOfIteratorHelper(this.paths),
              _step33;

          try {
            for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
              var path = _step33.value;
              path.fillMode = state;
              path.draw();
            }
          } catch (err) {
            _iterator33.e(err);
          } finally {
            _iterator33.f();
          }

          this.fillMode = state;
          this.settings.FillMode = state;
        }
        /**
         * Set the state of the "history" effect flag
         * @param {boolean} state Next state for the "history" effect flag
         */

      }, {
        key: "setDrawHistory",
        value: function setDrawHistory(state) {
          this.drawBackground();

          var _iterator34 = _createForOfIteratorHelper(this.paths),
              _step34;

          try {
            for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
              var path = _step34.value;
              path.drawHistory = state;
              path.draw();
            }
          } catch (err) {
            _iterator34.e(err);
          } finally {
            _iterator34.f();
          }

          this.drawHistory = state;
          this.settings.DrawHistory = state;
        }
        /**
         * Set the state of the "trace mode" flag
         * @param {boolean} state Next state for the "trace mode" flag
         */

      }, {
        key: "setTraceMode",
        value: function setTraceMode(state) {
          this.traceMode = state;
          this.settings.TraceMode = state;
          this.drawBackground();

          var _iterator35 = _createForOfIteratorHelper(this.paths),
              _step35;

          try {
            for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
              var path = _step35.value;
              path.traceMode = state;
            }
          } catch (err) {
            _iterator35.e(err);
          } finally {
            _iterator35.f();
          }
        }
        /**
         * Set the state of the "invert colors" flag
         * @param {boolean} state Next state for the "invert colors" flag
         */

      }, {
        key: "setInvertedColors",
        value: function setInvertedColors(state) {
          this.invertedColors = state;
          this.settings.InvertedColors = state;
          this.drawBackground();

          var _iterator36 = _createForOfIteratorHelper(this.paths),
              _step36;

          try {
            for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
              var path = _step36.value;
              path.invertedColors = state;
            }
          } catch (err) {
            _iterator36.e(err);
          } finally {
            _iterator36.f();
          }
        }
        /**
         * Set the state of the Bounds visibility flag
         * @param {boolean} state Next state for the Bounds visibility flag
         */

      }, {
        key: "setDrawBounds",
        value: function setDrawBounds(state) {
          this.drawBackground();

          var _iterator37 = _createForOfIteratorHelper(this.paths),
              _step37;

          try {
            for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
              var path = _step37.value;
              path.showBounds = state;
              path.draw();
            }
          } catch (err) {
            _iterator37.e(err);
          } finally {
            _iterator37.f();
          }

          this.showBounds = state;
        }
        /** Toggle the state of the Node visibility flag */

      }, {
        key: "toggleDrawNodes",
        value: function toggleDrawNodes() {
          this.setDrawNodes(!this.getDrawNodes());
        }
        /** Toggle the state of the "trace mode" effect flag */

      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.traceMode = !this.traceMode;
          this.drawBackground();

          var _iterator38 = _createForOfIteratorHelper(this.paths),
              _step38;

          try {
            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
              var path = _step38.value;
              path.toggleTraceMode();
              path.draw();
            }
          } catch (err) {
            _iterator38.e(err);
          } finally {
            _iterator38.f();
          }
        }
        /** Toggle the state of the "invert colors" flag */

      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.invertedColors = !this.invertedColors;
          this.drawBackground();

          var _iterator39 = _createForOfIteratorHelper(this.paths),
              _step39;

          try {
            for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
              var path = _step39.value;
              path.toggleInvertedColors();
              path.draw();
            }
          } catch (err) {
            _iterator39.e(err);
          } finally {
            _iterator39.f();
          }
        }
        /** Toggle the state of the "debug mode" flag */

      }, {
        key: "toggleDebugMode",
        value: function toggleDebugMode() {
          this.setDebugMode(!this.getDebugMode());
        }
        /** Toggle the state of the "fill mode" flag */

      }, {
        key: "toggleFillMode",
        value: function toggleFillMode() {
          this.setFillMode(!this.getFillMode());
        }
        /** Toggle the state of the "history" effect flag */

      }, {
        key: "toggleDrawHistory",
        value: function toggleDrawHistory() {
          this.setDrawHistory(!this.getDrawHistory());
        }
        /** Toggle the state of the Bounds visibility flag */

      }, {
        key: "toggleDrawBounds",
        value: function toggleDrawBounds() {
          this.setDrawBounds(!this.getDrawBounds());
        }
        /** Toggle the pause/unpause state of the simulation */

      }, {
        key: "togglePause",
        value: function togglePause() {
          if (this.paused) {
            this.unpause();
          } else {
            this.pause();
          }
        }
      }]);

      return World;
    }();

    module.exports = World;
  }, {
    "./Defaults": 2,
    "./node_modules/file-saver": 7,
    "./node_modules/rbush": 11,
    "./node_modules/svg-points/": 13
  }],
  7: [function (require, module, exports) {
    (function (global) {
      (function (a, b) {
        if ("function" == typeof define && define.amd) define([], b);else if ("undefined" != typeof exports) b();else {
          b(), a.FileSaver = {
            exports: {}
          }.exports;
        }
      })(this, function () {
        "use strict";

        function b(a, b) {
          return "undefined" == typeof b ? b = {
            autoBom: !1
          } : "object" != _typeof2(b) && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
          }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob(["\uFEFF", a], {
            type: a.type
          }) : a;
        }

        function c(b, c, d) {
          var e = new XMLHttpRequest();
          e.open("GET", b), e.responseType = "blob", e.onload = function () {
            a(e.response, c, d);
          }, e.onerror = function () {
            console.error("could not download file");
          }, e.send();
        }

        function d(a) {
          var b = new XMLHttpRequest();
          return b.open("HEAD", a, !1), b.send(), 200 <= b.status && 299 >= b.status;
        }

        function e(a) {
          try {
            a.dispatchEvent(new MouseEvent("click"));
          } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
          }
        }

        var f = "object" == (typeof window === "undefined" ? "undefined" : _typeof2(window)) && window.window === window ? window : "object" == (typeof self === "undefined" ? "undefined" : _typeof2(self)) && self.self === self ? self : "object" == _typeof2(global) && global.global === global ? global : void 0,
            a = f.saveAs || ("object" != (typeof window === "undefined" ? "undefined" : _typeof2(window)) || window !== f ? function () {} : "download" in HTMLAnchorElement.prototype ? function (b, g, h) {
          var i = f.URL || f.webkitURL,
              j = document.createElement("a");
          g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function () {
            i.revokeObjectURL(j.href);
          }, 4E4), setTimeout(function () {
            e(j);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function (f, g, h) {
          if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);else if (d(f)) c(f, g, h);else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function () {
              e(i);
            });
          }
        } : function (a, b, d, e) {
          if (e = e || open("", "_blank"), e && (e.document.title = e.document.body.innerText = "downloading..."), "string" == typeof a) return c(a, b, d);
          var g = "application/octet-stream" === a.type,
              h = /constructor/i.test(f.HTMLElement) || f.safari,
              i = /CriOS\/[\d]+/.test(navigator.userAgent);

          if ((i || g && h) && "object" == (typeof FileReader === "undefined" ? "undefined" : _typeof2(FileReader))) {
            var j = new FileReader();
            j.onloadend = function () {
              var a = j.result;
              a = i ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), e ? e.location.href = a : location = a, e = null;
            }, j.readAsDataURL(a);
          } else {
            var k = f.URL || f.webkitURL,
                l = k.createObjectURL(a);
            e ? e.location = l : location.href = l, e = null, setTimeout(function () {
              k.revokeObjectURL(l);
            }, 4E4);
          }
        });
        f.saveAs = a.saveAs = a, "undefined" != typeof module && (module.exports = a);
      });
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  8: [function (require, module, exports) {
    module.exports = function (point, vs) {
      // ray-casting algorithm based on
      // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
      var x = point[0],
          y = point[1];
      var inside = false;

      for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i][0],
            yi = vs[i][1];
        var xj = vs[j][0],
            yj = vs[j][1];
        var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }

      return inside;
    };
  }, {}],
  9: [function (require, module, exports) {
    (function (global, factory) {
      _typeof2(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
    })(this, function () {
      'use strict';

      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }

      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;

            while (compare(arr[i], t) < 0) {
              i++;
            }

            while (compare(arr[j], t) > 0) {
              j--;
            }
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      return quickselect;
    });
  }, {}],
  10: [function (require, module, exports) {
    'use strict';

    var Queue = require('tinyqueue');

    module.exports = knn;
    module.exports["default"] = knn;

    function knn(tree, x, y, n, predicate, maxDistance) {
      var node = tree.data,
          result = [],
          toBBox = tree.toBBox,
          i,
          child,
          dist,
          candidate;
      var queue = new Queue(null, compareDist);

      while (node) {
        for (i = 0; i < node.children.length; i++) {
          child = node.children[i];
          dist = boxDist(x, y, node.leaf ? toBBox(child) : child);

          if (!maxDistance || dist <= maxDistance) {
            queue.push({
              node: child,
              isItem: node.leaf,
              dist: dist
            });
          }
        }

        while (queue.length && queue.peek().isItem) {
          candidate = queue.pop().node;
          if (!predicate || predicate(candidate)) result.push(candidate);
          if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
      }

      return result;
    }

    function compareDist(a, b) {
      return a.dist - b.dist;
    }

    function boxDist(x, y, box) {
      var dx = axisDist(x, box.minX, box.maxX),
          dy = axisDist(y, box.minY, box.maxY);
      return dx * dx + dy * dy;
    }

    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
  }, {
    "tinyqueue": 17
  }],
  11: [function (require, module, exports) {
    'use strict';

    module.exports = rbush;
    module.exports["default"] = rbush;

    var quickselect = require('quickselect');

    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
        this._initFormat(format);
      }

      this.clear();
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return false;
      },
      load: function load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        } // recursively build the tree with the given data from scratch using OMT algorithm


        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;
        } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          } // insert the small tree into the large tree at appropriate level


          this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
      },
      insert: function insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function clear() {
        this.data = createNode([]);
        return this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;
        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp; // depth-first iterative tree traversal

        while (node || path.length) {
          if (!node) {
            // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }

          if (node.leaf) {
            // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
              // item found, remove the item and condense tree upwards
              node.children.splice(index, 1);
              path.push(node);

              this._condense(path);

              return this;
            }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) {
            // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            // go right
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null; // nothing found

        }

        return this;
      },
      toBBox: function toBBox(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        this.data = data;
        return this;
      },
      _all: function _all(node, result) {
        var nodesToSearch = [];

        while (node) {
          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }

        if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

          M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height; // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;
        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);

          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

            node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;

          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              // otherwise choose one with the smallest area
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, isNode) {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


        node.children.push(item);
        extend(node, bbox); // split on node overflow; propagate upwards if necessary

        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);

            level--;
          } else break;
        } // adjust bboxes along the insertion path


        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }

        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY


        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function _initFormat(format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = ['return a', ' - b', ';'];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
      }
    };

    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }

      return -1;
    } // calculate node's bbox from bboxes of its children


    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    } // min bounding rectangle of node children from k to p-1


    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach


    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }, {
    "quickselect": 9
  }],
  12: [function (require, module, exports) {
    !function (t, r) {
      "object" == _typeof2(exports) && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r(t.svgpathdata = {});
    }(this, function (t) {
      "use strict";

      var r = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (t, r) {
        t.__proto__ = r;
      } || function (t, r) {
        for (var e in r) {
          r.hasOwnProperty(e) && (t[e] = r[e]);
        }
      };

      function e(t, e) {
        function a() {
          this.constructor = t;
        }

        r(t, e), t.prototype = null === e ? Object.create(e) : (a.prototype = e.prototype, new a());
      }

      function a(t, r) {
        var e = t[0],
            a = t[1];
        return [e * Math.cos(r) - a * Math.sin(r), e * Math.sin(r) + a * Math.cos(r)];
      }

      function n() {
        for (var t = [], r = 0; r < arguments.length; r++) {
          t[r] = arguments[r];
        }

        for (var e = 0; e < t.length; e++) {
          if ("number" != typeof t[e]) throw new Error("assertNumbers arguments[" + e + "] is not a number. " + _typeof2(t[e]) + " == typeof " + t[e]);
        }

        return !0;
      }

      var i = Math.PI;

      function o(t, r, e) {
        t.lArcFlag = 0 === t.lArcFlag ? 0 : 1, t.sweepFlag = 0 === t.sweepFlag ? 0 : 1;
        var n = t.rX,
            o = t.rY,
            s = t.x,
            u = t.y;
        n = Math.abs(t.rX), o = Math.abs(t.rY);
        var h = a([(r - s) / 2, (e - u) / 2], -t.xRot / 180 * i),
            c = h[0],
            m = h[1],
            y = Math.pow(c, 2) / Math.pow(n, 2) + Math.pow(m, 2) / Math.pow(o, 2);
        1 < y && (n *= Math.sqrt(y), o *= Math.sqrt(y)), t.rX = n, t.rY = o;

        var p = Math.pow(n, 2) * Math.pow(m, 2) + Math.pow(o, 2) * Math.pow(c, 2),
            T = (t.lArcFlag !== t.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(n, 2) * Math.pow(o, 2) - p) / p)),
            O = n * m / o * T,
            _ = -o * c / n * T,
            f = a([O, _], t.xRot / 180 * i);

        t.cX = f[0] + (r + s) / 2, t.cY = f[1] + (e + u) / 2, t.phi1 = Math.atan2((m - _) / o, (c - O) / n), t.phi2 = Math.atan2((-m - _) / o, (-c - O) / n), 0 === t.sweepFlag && t.phi2 > t.phi1 && (t.phi2 -= 2 * i), 1 === t.sweepFlag && t.phi2 < t.phi1 && (t.phi2 += 2 * i), t.phi1 *= 180 / i, t.phi2 *= 180 / i;
      }

      function s(t, r, e) {
        n(t, r, e);
        var a = t * t + r * r - e * e;
        if (0 > a) return [];
        if (0 === a) return [[t * e / (t * t + r * r), r * e / (t * t + r * r)]];
        var i = Math.sqrt(a);
        return [[(t * e + r * i) / (t * t + r * r), (r * e - t * i) / (t * t + r * r)], [(t * e - r * i) / (t * t + r * r), (r * e + t * i) / (t * t + r * r)]];
      }

      var u = Math.PI / 180;

      function h(t, r, e) {
        return (1 - e) * t + e * r;
      }

      function c(t, r, e, a) {
        return t + Math.cos(a / 180 * i) * r + Math.sin(a / 180 * i) * e;
      }

      function m(t, r, e, a) {
        var n = r - t,
            i = e - r,
            o = 3 * n + 3 * (a - e) - 6 * i,
            s = 6 * (i - n),
            u = 3 * n;
        return Math.abs(o) < 1e-6 ? [-u / s] : function (t, r, e) {
          void 0 === e && (e = 1e-6);
          var a = t * t / 4 - r;
          if (a < -e) return [];
          if (a <= e) return [-t / 2];
          var n = Math.sqrt(a);
          return [-t / 2 - n, -t / 2 + n];
        }(s / o, u / o, 1e-6);
      }

      function y(t, r, e, a, n) {
        var i = 1 - n;
        return t * (i * i * i) + r * (3 * i * i * n) + e * (3 * i * n * n) + a * (n * n * n);
      }

      !function (t) {
        function r() {
          return p(function (t, r, e) {
            return t.relative && (void 0 !== t.x1 && (t.x1 += r), void 0 !== t.y1 && (t.y1 += e), void 0 !== t.x2 && (t.x2 += r), void 0 !== t.y2 && (t.y2 += e), void 0 !== t.x && (t.x += r), void 0 !== t.y && (t.y += e), t.relative = !1), t;
          });
        }

        function e() {
          var t = NaN,
              r = NaN,
              e = NaN,
              a = NaN;
          return p(function (n, i, o) {
            return n.type & l.SMOOTH_CURVE_TO && (n.type = l.CURVE_TO, t = isNaN(t) ? i : t, r = isNaN(r) ? o : r, n.x1 = n.relative ? i - t : 2 * i - t, n.y1 = n.relative ? o - r : 2 * o - r), n.type & l.CURVE_TO ? (t = n.relative ? i + n.x2 : n.x2, r = n.relative ? o + n.y2 : n.y2) : (t = NaN, r = NaN), n.type & l.SMOOTH_QUAD_TO && (n.type = l.QUAD_TO, e = isNaN(e) ? i : e, a = isNaN(a) ? o : a, n.x1 = n.relative ? i - e : 2 * i - e, n.y1 = n.relative ? o - a : 2 * o - a), n.type & l.QUAD_TO ? (e = n.relative ? i + n.x1 : n.x1, a = n.relative ? o + n.y1 : n.y1) : (e = NaN, a = NaN), n;
          });
        }

        function i() {
          var t = NaN,
              r = NaN;
          return p(function (e, a, n) {
            if (e.type & l.SMOOTH_QUAD_TO && (e.type = l.QUAD_TO, t = isNaN(t) ? a : t, r = isNaN(r) ? n : r, e.x1 = e.relative ? a - t : 2 * a - t, e.y1 = e.relative ? n - r : 2 * n - r), e.type & l.QUAD_TO) {
              t = e.relative ? a + e.x1 : e.x1, r = e.relative ? n + e.y1 : e.y1;
              var i = e.x1,
                  o = e.y1;
              e.type = l.CURVE_TO, e.x1 = ((e.relative ? 0 : a) + 2 * i) / 3, e.y1 = ((e.relative ? 0 : n) + 2 * o) / 3, e.x2 = (e.x + 2 * i) / 3, e.y2 = (e.y + 2 * o) / 3;
            } else t = NaN, r = NaN;

            return e;
          });
        }

        function p(t) {
          var r = 0,
              e = 0,
              a = NaN,
              n = NaN;
          return function (i) {
            if (isNaN(a) && !(i.type & l.MOVE_TO)) throw new Error("path must start with moveto");
            var o = t(i, r, e, a, n);
            return i.type & l.CLOSE_PATH && (r = a, e = n), void 0 !== i.x && (r = i.relative ? r + i.x : i.x), void 0 !== i.y && (e = i.relative ? e + i.y : i.y), i.type & l.MOVE_TO && (a = r, n = e), o;
          };
        }

        function T(t, r, e, a, i, o) {
          return n(t, r, e, a, i, o), p(function (n, s, u, h) {
            var c = n.x1,
                m = n.x2,
                y = n.relative && !isNaN(h),
                p = void 0 !== n.x ? n.x : y ? 0 : s,
                T = void 0 !== n.y ? n.y : y ? 0 : u;

            function O(t) {
              return t * t;
            }

            n.type & l.HORIZ_LINE_TO && 0 !== r && (n.type = l.LINE_TO, n.y = n.relative ? 0 : u), n.type & l.VERT_LINE_TO && 0 !== e && (n.type = l.LINE_TO, n.x = n.relative ? 0 : s), void 0 !== n.x && (n.x = n.x * t + T * e + (y ? 0 : i)), void 0 !== n.y && (n.y = p * r + n.y * a + (y ? 0 : o)), void 0 !== n.x1 && (n.x1 = n.x1 * t + n.y1 * e + (y ? 0 : i)), void 0 !== n.y1 && (n.y1 = c * r + n.y1 * a + (y ? 0 : o)), void 0 !== n.x2 && (n.x2 = n.x2 * t + n.y2 * e + (y ? 0 : i)), void 0 !== n.y2 && (n.y2 = m * r + n.y2 * a + (y ? 0 : o));

            var _ = t * a - r * e;

            if (void 0 !== n.xRot && (1 !== t || 0 !== r || 0 !== e || 1 !== a)) if (0 === _) delete n.rX, delete n.rY, delete n.xRot, delete n.lArcFlag, delete n.sweepFlag, n.type = l.LINE_TO;else {
              var f = n.xRot * Math.PI / 180,
                  v = Math.sin(f),
                  N = Math.cos(f),
                  E = 1 / O(n.rX),
                  d = 1 / O(n.rY),
                  A = O(N) * E + O(v) * d,
                  x = 2 * v * N * (E - d),
                  C = O(v) * E + O(N) * d,
                  M = A * a * a - x * r * a + C * r * r,
                  R = x * (t * a + r * e) - 2 * (A * e * a + C * t * r),
                  S = A * e * e - x * t * e + C * t * t,
                  I = (Math.atan2(R, M - S) + Math.PI) % Math.PI / 2,
                  g = Math.sin(I),
                  V = Math.cos(I);
              n.rX = Math.abs(_) / Math.sqrt(M * O(V) + R * g * V + S * O(g)), n.rY = Math.abs(_) / Math.sqrt(M * O(g) - R * g * V + S * O(V)), n.xRot = 180 * I / Math.PI;
            }
            return void 0 !== n.sweepFlag && 0 > _ && (n.sweepFlag = +!n.sweepFlag), n;
          });
        }

        function O() {
          return function (t) {
            var r = {};

            for (var e in t) {
              r[e] = t[e];
            }

            return r;
          };
        }

        t.ROUND = function (t) {
          function r(r) {
            return Math.round(r * t) / t;
          }

          return void 0 === t && (t = 1e13), n(t), function (t) {
            return void 0 !== t.x1 && (t.x1 = r(t.x1)), void 0 !== t.y1 && (t.y1 = r(t.y1)), void 0 !== t.x2 && (t.x2 = r(t.x2)), void 0 !== t.y2 && (t.y2 = r(t.y2)), void 0 !== t.x && (t.x = r(t.x)), void 0 !== t.y && (t.y = r(t.y)), t;
          };
        }, t.TO_ABS = r, t.TO_REL = function () {
          return p(function (t, r, e) {
            return t.relative || (void 0 !== t.x1 && (t.x1 -= r), void 0 !== t.y1 && (t.y1 -= e), void 0 !== t.x2 && (t.x2 -= r), void 0 !== t.y2 && (t.y2 -= e), void 0 !== t.x && (t.x -= r), void 0 !== t.y && (t.y -= e), t.relative = !0), t;
          });
        }, t.NORMALIZE_HVZ = function (t, r, e) {
          return void 0 === t && (t = !0), void 0 === r && (r = !0), void 0 === e && (e = !0), p(function (a, n, i, o, s) {
            if (isNaN(o) && !(a.type & l.MOVE_TO)) throw new Error("path must start with moveto");
            return r && a.type & l.HORIZ_LINE_TO && (a.type = l.LINE_TO, a.y = a.relative ? 0 : i), e && a.type & l.VERT_LINE_TO && (a.type = l.LINE_TO, a.x = a.relative ? 0 : n), t && a.type & l.CLOSE_PATH && (a.type = l.LINE_TO, a.x = a.relative ? o - n : o, a.y = a.relative ? s - i : s), a.type & l.ARC && (0 === a.rX || 0 === a.rY) && (a.type = l.LINE_TO, delete a.rX, delete a.rY, delete a.xRot, delete a.lArcFlag, delete a.sweepFlag), a;
          });
        }, t.NORMALIZE_ST = e, t.QT_TO_C = i, t.INFO = p, t.SANITIZE = function (t) {
          void 0 === t && (t = 0), n(t);
          var r = NaN,
              e = NaN,
              a = NaN,
              i = NaN;
          return p(function (n, o, s, u, h) {
            var c = Math.abs,
                m = !1,
                y = 0,
                p = 0;

            if (n.type & l.SMOOTH_CURVE_TO && (y = isNaN(r) ? 0 : o - r, p = isNaN(e) ? 0 : s - e), n.type & (l.CURVE_TO | l.SMOOTH_CURVE_TO) ? (r = n.relative ? o + n.x2 : n.x2, e = n.relative ? s + n.y2 : n.y2) : (r = NaN, e = NaN), n.type & l.SMOOTH_QUAD_TO ? (a = isNaN(a) ? o : 2 * o - a, i = isNaN(i) ? s : 2 * s - i) : n.type & l.QUAD_TO ? (a = n.relative ? o + n.x1 : n.x1, i = n.relative ? s + n.y1 : n.y2) : (a = NaN, i = NaN), n.type & l.LINE_COMMANDS || n.type & l.ARC && (0 === n.rX || 0 === n.rY || !n.lArcFlag) || n.type & l.CURVE_TO || n.type & l.SMOOTH_CURVE_TO || n.type & l.QUAD_TO || n.type & l.SMOOTH_QUAD_TO) {
              var T = void 0 === n.x ? 0 : n.relative ? n.x : n.x - o,
                  O = void 0 === n.y ? 0 : n.relative ? n.y : n.y - s;
              y = isNaN(a) ? void 0 === n.x1 ? y : n.relative ? n.x : n.x1 - o : a - o, p = isNaN(i) ? void 0 === n.y1 ? p : n.relative ? n.y : n.y1 - s : i - s;

              var _ = void 0 === n.x2 ? 0 : n.relative ? n.x : n.x2 - o,
                  f = void 0 === n.y2 ? 0 : n.relative ? n.y : n.y2 - s;

              c(T) <= t && c(O) <= t && c(y) <= t && c(p) <= t && c(_) <= t && c(f) <= t && (m = !0);
            }

            return n.type & l.CLOSE_PATH && c(o - u) <= t && c(s - h) <= t && (m = !0), m ? [] : n;
          });
        }, t.MATRIX = T, t.ROTATE = function (t, r, e) {
          void 0 === r && (r = 0), void 0 === e && (e = 0), n(t, r, e);
          var a = Math.sin(t),
              i = Math.cos(t);
          return T(i, a, -a, i, r - r * i + e * a, e - r * a - e * i);
        }, t.TRANSLATE = function (t, r) {
          return void 0 === r && (r = 0), n(t, r), T(1, 0, 0, 1, t, r);
        }, t.SCALE = function (t, r) {
          return void 0 === r && (r = t), n(t, r), T(t, 0, 0, r, 0, 0);
        }, t.SKEW_X = function (t) {
          return n(t), T(1, 0, Math.atan(t), 1, 0, 0);
        }, t.SKEW_Y = function (t) {
          return n(t), T(1, Math.atan(t), 0, 1, 0, 0);
        }, t.X_AXIS_SYMMETRY = function (t) {
          return void 0 === t && (t = 0), n(t), T(-1, 0, 0, 1, t, 0);
        }, t.Y_AXIS_SYMMETRY = function (t) {
          return void 0 === t && (t = 0), n(t), T(1, 0, 0, -1, 0, t);
        }, t.A_TO_C = function () {
          return p(function (t, r, e) {
            return l.ARC === t.type ? function (t, r, e) {
              var n, i, s, c;
              t.cX || o(t, r, e);

              for (var m = Math.min(t.phi1, t.phi2), y = Math.max(t.phi1, t.phi2) - m, p = Math.ceil(y / 90), T = new Array(p), O = r, _ = e, f = 0; f < p; f++) {
                var v = h(t.phi1, t.phi2, f / p),
                    N = h(t.phi1, t.phi2, (f + 1) / p),
                    E = N - v,
                    d = 4 / 3 * Math.tan(E * u / 4),
                    A = [Math.cos(v * u) - d * Math.sin(v * u), Math.sin(v * u) + d * Math.cos(v * u)],
                    x = A[0],
                    C = A[1],
                    M = [Math.cos(N * u), Math.sin(N * u)],
                    R = M[0],
                    S = M[1],
                    I = [R + d * Math.sin(N * u), S - d * Math.cos(N * u)],
                    g = I[0],
                    V = I[1];
                T[f] = {
                  relative: t.relative,
                  type: l.CURVE_TO
                };

                var L = function L(r, e) {
                  var n = a([r * t.rX, e * t.rY], t.xRot),
                      i = n[0],
                      o = n[1];
                  return [t.cX + i, t.cY + o];
                };

                n = L(x, C), T[f].x1 = n[0], T[f].y1 = n[1], i = L(g, V), T[f].x2 = i[0], T[f].y2 = i[1], s = L(R, S), T[f].x = s[0], T[f].y = s[1], t.relative && (T[f].x1 -= O, T[f].y1 -= _, T[f].x2 -= O, T[f].y2 -= _, T[f].x -= O, T[f].y -= _), O = (c = [T[f].x, T[f].y])[0], _ = c[1];
              }

              return T;
            }(t, t.relative ? 0 : r, t.relative ? 0 : e) : t;
          });
        }, t.ANNOTATE_ARCS = function () {
          return p(function (t, r, e) {
            return t.relative && (r = 0, e = 0), l.ARC === t.type && o(t, r, e), t;
          });
        }, t.CLONE = O, t.CALCULATE_BOUNDS = function () {
          var t = function t(_t) {
            var r = {};

            for (var e in _t) {
              r[e] = _t[e];
            }

            return r;
          },
              a = r(),
              n = i(),
              u = e(),
              h = p(function (r, e, i) {
            var p = u(n(a(t(r))));

            function T(t) {
              t > h.maxX && (h.maxX = t), t < h.minX && (h.minX = t);
            }

            function O(t) {
              t > h.maxY && (h.maxY = t), t < h.minY && (h.minY = t);
            }

            if (p.type & l.DRAWING_COMMANDS && (T(e), O(i)), p.type & l.HORIZ_LINE_TO && T(p.x), p.type & l.VERT_LINE_TO && O(p.y), p.type & l.LINE_TO && (T(p.x), O(p.y)), p.type & l.CURVE_TO) {
              T(p.x), O(p.y);

              for (var _ = 0, f = m(e, p.x1, p.x2, p.x); _ < f.length; _++) {
                0 < (U = f[_]) && 1 > U && T(y(e, p.x1, p.x2, p.x, U));
              }

              for (var v = 0, N = m(i, p.y1, p.y2, p.y); v < N.length; v++) {
                0 < (U = N[v]) && 1 > U && O(y(i, p.y1, p.y2, p.y, U));
              }
            }

            if (p.type & l.ARC) {
              T(p.x), O(p.y), o(p, e, i);

              for (var E = p.xRot / 180 * Math.PI, d = Math.cos(E) * p.rX, A = Math.sin(E) * p.rX, x = -Math.sin(E) * p.rY, C = Math.cos(E) * p.rY, M = p.phi1 < p.phi2 ? [p.phi1, p.phi2] : -180 > p.phi2 ? [p.phi2 + 360, p.phi1 + 360] : [p.phi2, p.phi1], R = M[0], S = M[1], I = function I(t) {
                var r = t[0],
                    e = t[1],
                    a = 180 * Math.atan2(e, r) / Math.PI;
                return a < R ? a + 360 : a;
              }, g = 0, V = s(x, -d, 0).map(I); g < V.length; g++) {
                (U = V[g]) > R && U < S && T(c(p.cX, d, x, U));
              }

              for (var L = 0, D = s(C, -A, 0).map(I); L < D.length; L++) {
                var U;
                (U = D[L]) > R && U < S && O(c(p.cY, A, C, U));
              }
            }

            return r;
          });

          return h.minX = 1 / 0, h.maxX = -1 / 0, h.minY = 1 / 0, h.maxY = -1 / 0, h;
        };
      }(t.SVGPathDataTransformer || (t.SVGPathDataTransformer = {}));

      var p,
          T,
          O = function () {
        function r() {}

        return r.prototype.round = function (r) {
          return this.transform(t.SVGPathDataTransformer.ROUND(r));
        }, r.prototype.toAbs = function () {
          return this.transform(t.SVGPathDataTransformer.TO_ABS());
        }, r.prototype.toRel = function () {
          return this.transform(t.SVGPathDataTransformer.TO_REL());
        }, r.prototype.normalizeHVZ = function (r, e, a) {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_HVZ(r, e, a));
        }, r.prototype.normalizeST = function () {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_ST());
        }, r.prototype.qtToC = function () {
          return this.transform(t.SVGPathDataTransformer.QT_TO_C());
        }, r.prototype.aToC = function () {
          return this.transform(t.SVGPathDataTransformer.A_TO_C());
        }, r.prototype.sanitize = function (r) {
          return this.transform(t.SVGPathDataTransformer.SANITIZE(r));
        }, r.prototype.translate = function (r, e) {
          return this.transform(t.SVGPathDataTransformer.TRANSLATE(r, e));
        }, r.prototype.scale = function (r, e) {
          return this.transform(t.SVGPathDataTransformer.SCALE(r, e));
        }, r.prototype.rotate = function (r, e, a) {
          return this.transform(t.SVGPathDataTransformer.ROTATE(r, e, a));
        }, r.prototype.matrix = function (r, e, a, n, i, o) {
          return this.transform(t.SVGPathDataTransformer.MATRIX(r, e, a, n, i, o));
        }, r.prototype.skewX = function (r) {
          return this.transform(t.SVGPathDataTransformer.SKEW_X(r));
        }, r.prototype.skewY = function (r) {
          return this.transform(t.SVGPathDataTransformer.SKEW_Y(r));
        }, r.prototype.xSymmetry = function (r) {
          return this.transform(t.SVGPathDataTransformer.X_AXIS_SYMMETRY(r));
        }, r.prototype.ySymmetry = function (r) {
          return this.transform(t.SVGPathDataTransformer.Y_AXIS_SYMMETRY(r));
        }, r.prototype.annotateArcs = function () {
          return this.transform(t.SVGPathDataTransformer.ANNOTATE_ARCS());
        }, r;
      }(),
          _ = function _(t) {
        return " " === t || "\t" === t || "\r" === t || "\n" === t;
      },
          f = function f(t) {
        return "0".charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= "9".charCodeAt(0);
      },
          v = function (t) {
        function r() {
          var r = t.call(this) || this;
          return r.curNumber = "", r.curCommandType = -1, r.curCommandRelative = !1, r.canParseCommandOrComma = !0, r.curNumberHasExp = !1, r.curNumberHasExpDigits = !1, r.curNumberHasDecimal = !1, r.curArgs = [], r;
        }

        return e(r, t), r.prototype.finish = function (t) {
          if (void 0 === t && (t = []), this.parse(" ", t), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
          return t;
        }, r.prototype.parse = function (t, r) {
          var e = this;
          void 0 === r && (r = []);

          for (var a = function a(t) {
            r.push(t), e.curArgs.length = 0, e.canParseCommandOrComma = !0;
          }, n = 0; n < t.length; n++) {
            var i = t[n];
            if (f(i)) this.curNumber += i, this.curNumberHasExpDigits = this.curNumberHasExp;else if ("e" !== i && "E" !== i) {
              if ("-" !== i && "+" !== i || !this.curNumberHasExp || this.curNumberHasExpDigits) {
                if ("." !== i || this.curNumberHasExp || this.curNumberHasDecimal) {
                  if (this.curNumber && -1 !== this.curCommandType) {
                    var o = Number(this.curNumber);
                    if (isNaN(o)) throw new SyntaxError("Invalid number ending at " + n);
                    if (this.curCommandType === l.ARC) if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                      if (0 > o) throw new SyntaxError('Expected positive number, got "' + o + '" at index "' + n + '"');
                    } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + n + '"');
                    this.curArgs.push(o), this.curArgs.length === N[this.curCommandType] && (l.HORIZ_LINE_TO === this.curCommandType ? a({
                      type: l.HORIZ_LINE_TO,
                      relative: this.curCommandRelative,
                      x: o
                    }) : l.VERT_LINE_TO === this.curCommandType ? a({
                      type: l.VERT_LINE_TO,
                      relative: this.curCommandRelative,
                      y: o
                    }) : this.curCommandType === l.MOVE_TO || this.curCommandType === l.LINE_TO || this.curCommandType === l.SMOOTH_QUAD_TO ? (a({
                      type: this.curCommandType,
                      relative: this.curCommandRelative,
                      x: this.curArgs[0],
                      y: this.curArgs[1]
                    }), l.MOVE_TO === this.curCommandType && (this.curCommandType = l.LINE_TO)) : this.curCommandType === l.CURVE_TO ? a({
                      type: l.CURVE_TO,
                      relative: this.curCommandRelative,
                      x1: this.curArgs[0],
                      y1: this.curArgs[1],
                      x2: this.curArgs[2],
                      y2: this.curArgs[3],
                      x: this.curArgs[4],
                      y: this.curArgs[5]
                    }) : this.curCommandType === l.SMOOTH_CURVE_TO ? a({
                      type: l.SMOOTH_CURVE_TO,
                      relative: this.curCommandRelative,
                      x2: this.curArgs[0],
                      y2: this.curArgs[1],
                      x: this.curArgs[2],
                      y: this.curArgs[3]
                    }) : this.curCommandType === l.QUAD_TO ? a({
                      type: l.QUAD_TO,
                      relative: this.curCommandRelative,
                      x1: this.curArgs[0],
                      y1: this.curArgs[1],
                      x: this.curArgs[2],
                      y: this.curArgs[3]
                    }) : this.curCommandType === l.ARC && a({
                      type: l.ARC,
                      relative: this.curCommandRelative,
                      rX: this.curArgs[0],
                      rY: this.curArgs[1],
                      xRot: this.curArgs[2],
                      lArcFlag: this.curArgs[3],
                      sweepFlag: this.curArgs[4],
                      x: this.curArgs[5],
                      y: this.curArgs[6]
                    })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
                  }

                  if (!_(i)) if ("," === i && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;else if ("+" !== i && "-" !== i && "." !== i) {
                    if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + n + ".");
                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + i + '" at index ' + n + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, "z" !== i && "Z" !== i) {
                      if ("h" === i || "H" === i) this.curCommandType = l.HORIZ_LINE_TO, this.curCommandRelative = "h" === i;else if ("v" === i || "V" === i) this.curCommandType = l.VERT_LINE_TO, this.curCommandRelative = "v" === i;else if ("m" === i || "M" === i) this.curCommandType = l.MOVE_TO, this.curCommandRelative = "m" === i;else if ("l" === i || "L" === i) this.curCommandType = l.LINE_TO, this.curCommandRelative = "l" === i;else if ("c" === i || "C" === i) this.curCommandType = l.CURVE_TO, this.curCommandRelative = "c" === i;else if ("s" === i || "S" === i) this.curCommandType = l.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === i;else if ("q" === i || "Q" === i) this.curCommandType = l.QUAD_TO, this.curCommandRelative = "q" === i;else if ("t" === i || "T" === i) this.curCommandType = l.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === i;else {
                        if ("a" !== i && "A" !== i) throw new SyntaxError('Unexpected character "' + i + '" at index ' + n + ".");
                        this.curCommandType = l.ARC, this.curCommandRelative = "a" === i;
                      }
                    } else r.push({
                      type: l.CLOSE_PATH
                    }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  } else this.curNumber = i, this.curNumberHasDecimal = "." === i;
                } else this.curNumber += i, this.curNumberHasDecimal = !0;
              } else this.curNumber += i;
            } else this.curNumber += i, this.curNumberHasExp = !0;
          }

          return r;
        }, r.prototype.transform = function (t) {
          return Object.create(this, {
            parse: {
              value: function value(r, e) {
                void 0 === e && (e = []);

                for (var a = 0, n = Object.getPrototypeOf(this).parse.call(this, r); a < n.length; a++) {
                  var i = n[a],
                      o = t(i);
                  Array.isArray(o) ? e.push.apply(e, o) : e.push(o);
                }

                return e;
              }
            }
          });
        }, r;
      }(O),
          l = function (r) {
        function a(t) {
          var e = r.call(this) || this;
          return e.commands = "string" == typeof t ? a.parse(t) : t, e;
        }

        return e(a, r), a.prototype.encode = function () {
          return a.encode(this.commands);
        }, a.prototype.getBounds = function () {
          var r = t.SVGPathDataTransformer.CALCULATE_BOUNDS();
          return this.transform(r), r;
        }, a.prototype.transform = function (t) {
          for (var r = [], e = 0, a = this.commands; e < a.length; e++) {
            var n = t(a[e]);
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          }

          return this.commands = r, this;
        }, a.encode = function (t) {
          return d(t);
        }, a.parse = function (t) {
          var r = new v(),
              e = [];
          return r.parse(t, e), r.finish(e), e;
        }, a.CLOSE_PATH = 1, a.MOVE_TO = 2, a.HORIZ_LINE_TO = 4, a.VERT_LINE_TO = 8, a.LINE_TO = 16, a.CURVE_TO = 32, a.SMOOTH_CURVE_TO = 64, a.QUAD_TO = 128, a.SMOOTH_QUAD_TO = 256, a.ARC = 512, a.LINE_COMMANDS = a.LINE_TO | a.HORIZ_LINE_TO | a.VERT_LINE_TO, a.DRAWING_COMMANDS = a.HORIZ_LINE_TO | a.VERT_LINE_TO | a.LINE_TO | a.CURVE_TO | a.SMOOTH_CURVE_TO | a.QUAD_TO | a.SMOOTH_QUAD_TO | a.ARC, a;
      }(O),
          N = ((p = {})[l.MOVE_TO] = 2, p[l.LINE_TO] = 2, p[l.HORIZ_LINE_TO] = 1, p[l.VERT_LINE_TO] = 1, p[l.CLOSE_PATH] = 0, p[l.QUAD_TO] = 4, p[l.SMOOTH_QUAD_TO] = 2, p[l.CURVE_TO] = 6, p[l.SMOOTH_CURVE_TO] = 4, p[l.ARC] = 7, p),
          E = " ";

      function d(t) {
        var r = "";
        Array.isArray(t) || (t = [t]);

        for (var e = 0; e < t.length; e++) {
          var a = t[e];
          if (a.type === l.CLOSE_PATH) r += "z";else if (a.type === l.HORIZ_LINE_TO) r += (a.relative ? "h" : "H") + a.x;else if (a.type === l.VERT_LINE_TO) r += (a.relative ? "v" : "V") + a.y;else if (a.type === l.MOVE_TO) r += (a.relative ? "m" : "M") + a.x + E + a.y;else if (a.type === l.LINE_TO) r += (a.relative ? "l" : "L") + a.x + E + a.y;else if (a.type === l.CURVE_TO) r += (a.relative ? "c" : "C") + a.x1 + E + a.y1 + E + a.x2 + E + a.y2 + E + a.x + E + a.y;else if (a.type === l.SMOOTH_CURVE_TO) r += (a.relative ? "s" : "S") + a.x2 + E + a.y2 + E + a.x + E + a.y;else if (a.type === l.QUAD_TO) r += (a.relative ? "q" : "Q") + a.x1 + E + a.y1 + E + a.x + E + a.y;else if (a.type === l.SMOOTH_QUAD_TO) r += (a.relative ? "t" : "T") + a.x + E + a.y;else {
            if (a.type !== l.ARC) throw new Error('Unexpected command type "' + a.type + '" at index ' + e + ".");
            r += (a.relative ? "a" : "A") + a.rX + E + a.rY + E + a.xRot + E + +a.lArcFlag + E + +a.sweepFlag + E + a.x + E + a.y;
          }
        }

        return r;
      }

      var A = function (r) {
        function a(t) {
          var e = r.call(this) || this;
          return e.commands = "string" == typeof t ? a.parse(t) : t, e;
        }

        return e(a, r), a.prototype.encode = function () {
          return a.encode(this.commands);
        }, a.prototype.getBounds = function () {
          var r = t.SVGPathDataTransformer.CALCULATE_BOUNDS();
          return this.transform(r), r;
        }, a.prototype.transform = function (t) {
          for (var r = [], e = 0, a = this.commands; e < a.length; e++) {
            var n = t(a[e]);
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          }

          return this.commands = r, this;
        }, a.encode = function (t) {
          return d(t);
        }, a.parse = function (t) {
          var r = new v(),
              e = [];
          return r.parse(t, e), r.finish(e), e;
        }, a.CLOSE_PATH = 1, a.MOVE_TO = 2, a.HORIZ_LINE_TO = 4, a.VERT_LINE_TO = 8, a.LINE_TO = 16, a.CURVE_TO = 32, a.SMOOTH_CURVE_TO = 64, a.QUAD_TO = 128, a.SMOOTH_QUAD_TO = 256, a.ARC = 512, a.LINE_COMMANDS = a.LINE_TO | a.HORIZ_LINE_TO | a.VERT_LINE_TO, a.DRAWING_COMMANDS = a.HORIZ_LINE_TO | a.VERT_LINE_TO | a.LINE_TO | a.CURVE_TO | a.SMOOTH_CURVE_TO | a.QUAD_TO | a.SMOOTH_QUAD_TO | a.ARC, a;
      }(O),
          x = ((T = {})[A.MOVE_TO] = 2, T[A.LINE_TO] = 2, T[A.HORIZ_LINE_TO] = 1, T[A.VERT_LINE_TO] = 1, T[A.CLOSE_PATH] = 0, T[A.QUAD_TO] = 4, T[A.SMOOTH_QUAD_TO] = 2, T[A.CURVE_TO] = 6, T[A.SMOOTH_CURVE_TO] = 4, T[A.ARC] = 7, T);

      t.SVGPathData = A, t.COMMAND_ARG_COUNTS = x, t.encodeSVGPath = d, t.SVGPathDataParser = v, Object.defineProperty(t, "__esModule", {
        value: !0
      });
    });
  }, {}],
  13: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valid = exports.toPoints = exports.toPath = undefined;

    var _toPath = require('./toPath');

    var _toPath2 = _interopRequireDefault(_toPath);

    var _toPoints = require('./toPoints');

    var _toPoints2 = _interopRequireDefault(_toPoints);

    var _valid = require('./valid');

    var _valid2 = _interopRequireDefault(_valid);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    exports.toPath = _toPath2["default"];
    exports.toPoints = _toPoints2["default"];
    exports.valid = _valid2["default"];
  }, {
    "./toPath": 14,
    "./toPoints": 15,
    "./valid": 16
  }],
  14: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _toPoints = require('./toPoints');

    var _toPoints2 = _interopRequireDefault(_toPoints);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var pointsToD = function pointsToD(p) {
      var d = '';
      var i = 0;
      var firstPoint = void 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = p[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var _point$curve = point.curve,
              curve = _point$curve === undefined ? false : _point$curve,
              moveTo = point.moveTo,
              x = point.x,
              y = point.y;
          var isFirstPoint = i === 0 || moveTo;
          var isLastPoint = i === p.length - 1 || p[i + 1].moveTo;
          var prevPoint = i === 0 ? null : p[i - 1];

          if (isFirstPoint) {
            firstPoint = point;

            if (!isLastPoint) {
              d += 'M' + x + ',' + y;
            }
          } else if (curve) {
            switch (curve.type) {
              case 'arc':
                var _point$curve2 = point.curve,
                    _point$curve2$largeAr = _point$curve2.largeArcFlag,
                    largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr,
                    rx = _point$curve2.rx,
                    ry = _point$curve2.ry,
                    _point$curve2$sweepFl = _point$curve2.sweepFlag,
                    sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl,
                    _point$curve2$xAxisRo = _point$curve2.xAxisRotation,
                    xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;
                d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
                break;

              case 'cubic':
                var _point$curve3 = point.curve,
                    cx1 = _point$curve3.x1,
                    cy1 = _point$curve3.y1,
                    cx2 = _point$curve3.x2,
                    cy2 = _point$curve3.y2;
                d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
                break;

              case 'quadratic':
                var _point$curve4 = point.curve,
                    qx1 = _point$curve4.x1,
                    qy1 = _point$curve4.y1;
                d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
                break;
            }

            if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
              d += 'Z';
            }
          } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
            d += 'Z';
          } else if (x !== prevPoint.x && y !== prevPoint.y) {
            d += 'L' + x + ',' + y;
          } else if (x !== prevPoint.x) {
            d += 'H' + x;
          } else if (y !== prevPoint.y) {
            d += 'V' + y;
          }

          i++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return d;
    };

    var toPath = function toPath(s) {
      var isPoints = Array.isArray(s);
      var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
      var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
        return (0, _toPoints2["default"])(shp);
      }) : (0, _toPoints2["default"])(s);

      if (isGroup) {
        return points.map(function (p) {
          return pointsToD(p);
        });
      }

      return pointsToD(points);
    };

    exports["default"] = toPath;
  }, {
    "./toPoints": 15
  }],
  15: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var toPoints = function toPoints(_ref) {
      var type = _ref.type,
          props = _objectWithoutProperties(_ref, ['type']);

      switch (type) {
        case 'circle':
          return getPointsFromCircle(props);

        case 'ellipse':
          return getPointsFromEllipse(props);

        case 'line':
          return getPointsFromLine(props);

        case 'path':
          return getPointsFromPath(props);

        case 'polygon':
          return getPointsFromPolygon(props);

        case 'polyline':
          return getPointsFromPolyline(props);

        case 'rect':
          return getPointsFromRect(props);

        case 'g':
          return getPointsFromG(props);

        default:
          throw new Error('Not a valid shape type');
      }
    };

    var getPointsFromCircle = function getPointsFromCircle(_ref2) {
      var cx = _ref2.cx,
          cy = _ref2.cy,
          r = _ref2.r;
      return [{
        x: cx,
        y: cy - r,
        moveTo: true
      }, {
        x: cx,
        y: cy + r,
        curve: {
          type: 'arc',
          rx: r,
          ry: r,
          sweepFlag: 1
        }
      }, {
        x: cx,
        y: cy - r,
        curve: {
          type: 'arc',
          rx: r,
          ry: r,
          sweepFlag: 1
        }
      }];
    };

    var getPointsFromEllipse = function getPointsFromEllipse(_ref3) {
      var cx = _ref3.cx,
          cy = _ref3.cy,
          rx = _ref3.rx,
          ry = _ref3.ry;
      return [{
        x: cx,
        y: cy - ry,
        moveTo: true
      }, {
        x: cx,
        y: cy + ry,
        curve: {
          type: 'arc',
          rx: rx,
          ry: ry,
          sweepFlag: 1
        }
      }, {
        x: cx,
        y: cy - ry,
        curve: {
          type: 'arc',
          rx: rx,
          ry: ry,
          sweepFlag: 1
        }
      }];
    };

    var getPointsFromLine = function getPointsFromLine(_ref4) {
      var x1 = _ref4.x1,
          x2 = _ref4.x2,
          y1 = _ref4.y1,
          y2 = _ref4.y2;
      return [{
        x: x1,
        y: y1,
        moveTo: true
      }, {
        x: x2,
        y: y2
      }];
    };

    var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;
    var commandLengths = {
      A: 7,
      C: 6,
      H: 1,
      L: 2,
      M: 2,
      Q: 4,
      S: 4,
      T: 2,
      V: 1,
      Z: 0
    };
    var relativeCommands = ['a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v'];

    var isRelative = function isRelative(command) {
      return relativeCommands.indexOf(command) !== -1;
    };

    var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

    var getCommands = function getCommands(d) {
      return d.match(validCommands);
    };

    var getParams = function getParams(d) {
      return d.split(validCommands).map(function (v) {
        return v.replace(/[0-9]+-/g, function (m) {
          return m.slice(0, -1) + ' -';
        });
      }).map(function (v) {
        return v.replace(/\.[0-9]+/g, function (m) {
          return m + ' ';
        });
      }).map(function (v) {
        return v.trim();
      }).filter(function (v) {
        return v.length > 0;
      }).map(function (v) {
        return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
          return !isNaN(n);
        });
      });
    };

    var getPointsFromPath = function getPointsFromPath(_ref5) {
      var d = _ref5.d;
      var commands = getCommands(d);
      var params = getParams(d);
      var points = [];
      var moveTo = void 0;

      for (var i = 0, l = commands.length; i < l; i++) {
        var command = commands[i];
        var upperCaseCommand = command.toUpperCase();
        var commandLength = commandLengths[upperCaseCommand];
        var relative = isRelative(command);

        if (commandLength > 0) {
          var commandParams = params.shift();
          var iterations = commandParams.length / commandLength;

          for (var j = 0; j < iterations; j++) {
            var prevPoint = points[points.length - 1] || {
              x: 0,
              y: 0
            };

            switch (upperCaseCommand) {
              case 'M':
                var x = (relative ? prevPoint.x : 0) + commandParams.shift();
                var y = (relative ? prevPoint.y : 0) + commandParams.shift();

                if (j === 0) {
                  moveTo = {
                    x: x,
                    y: y
                  };
                  points.push({
                    x: x,
                    y: y,
                    moveTo: true
                  });
                } else {
                  points.push({
                    x: x,
                    y: y
                  });
                }

                break;

              case 'L':
                points.push({
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'H':
                points.push({
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: prevPoint.y
                });
                break;

              case 'V':
                points.push({
                  x: prevPoint.x,
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'A':
                points.push({
                  curve: {
                    type: 'arc',
                    rx: commandParams.shift(),
                    ry: commandParams.shift(),
                    xAxisRotation: commandParams.shift(),
                    largeArcFlag: commandParams.shift(),
                    sweepFlag: commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = optionalArcKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var k = _step.value;

                    if (points[points.length - 1]['curve'][k] === 0) {
                      delete points[points.length - 1]['curve'][k];
                    }
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }

                break;

              case 'C':
                points.push({
                  curve: {
                    type: 'cubic',
                    x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
                    x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y2: (relative ? prevPoint.y : 0) + commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'S':
                var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
                var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
                var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
                var sy = (relative ? prevPoint.y : 0) + commandParams.shift();
                var diff = {};
                var sx1 = void 0;
                var sy1 = void 0;

                if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
                  diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
                  diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
                  sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
                  sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
                } else {
                  diff.x = Math.abs(sx - sx2);
                  diff.y = Math.abs(sy - sy2);
                  sx1 = prevPoint.x;
                  sy1 = prevPoint.y;
                }

                points.push({
                  curve: {
                    type: 'cubic',
                    x1: sx1,
                    y1: sy1,
                    x2: sx2,
                    y2: sy2
                  },
                  x: sx,
                  y: sy
                });
                break;

              case 'Q':
                points.push({
                  curve: {
                    type: 'quadratic',
                    x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y1: (relative ? prevPoint.y : 0) + commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'T':
                var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
                var ty = (relative ? prevPoint.y : 0) + commandParams.shift();
                var tx1 = void 0;
                var ty1 = void 0;

                if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
                  var _diff = {
                    x: Math.abs(prevPoint.x - prevPoint.curve.x1),
                    y: Math.abs(prevPoint.y - prevPoint.curve.y1)
                  };
                  tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
                  ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
                } else {
                  tx1 = prevPoint.x;
                  ty1 = prevPoint.y;
                }

                points.push({
                  curve: {
                    type: 'quadratic',
                    x1: tx1,
                    y1: ty1
                  },
                  x: tx,
                  y: ty
                });
                break;
            }
          }
        } else {
          var _prevPoint = points[points.length - 1] || {
            x: 0,
            y: 0
          };

          if (_prevPoint.x !== moveTo.x || _prevPoint.y !== moveTo.y) {
            points.push({
              x: moveTo.x,
              y: moveTo.y
            });
          }
        }
      }

      return points;
    };

    var getPointsFromPolygon = function getPointsFromPolygon(_ref6) {
      var points = _ref6.points;
      return getPointsFromPoints({
        closed: true,
        points: points
      });
    };

    var getPointsFromPolyline = function getPointsFromPolyline(_ref7) {
      var points = _ref7.points;
      return getPointsFromPoints({
        closed: false,
        points: points
      });
    };

    var getPointsFromPoints = function getPointsFromPoints(_ref8) {
      var closed = _ref8.closed,
          points = _ref8.points;
      var numbers = points.split(/[\s,]+/).map(function (n) {
        return parseFloat(n);
      });
      var p = numbers.reduce(function (arr, point, i) {
        if (i % 2 === 0) {
          arr.push({
            x: point
          });
        } else {
          arr[(i - 1) / 2].y = point;
        }

        return arr;
      }, []);

      if (closed) {
        p.push(_extends({}, p[0]));
      }

      p[0].moveTo = true;
      return p;
    };

    var getPointsFromRect = function getPointsFromRect(_ref9) {
      var height = _ref9.height,
          rx = _ref9.rx,
          ry = _ref9.ry,
          width = _ref9.width,
          x = _ref9.x,
          y = _ref9.y;

      if (rx || ry) {
        return getPointsFromRectWithCornerRadius({
          height: height,
          rx: rx || ry,
          ry: ry || rx,
          width: width,
          x: x,
          y: y
        });
      }

      return getPointsFromBasicRect({
        height: height,
        width: width,
        x: x,
        y: y
      });
    };

    var getPointsFromBasicRect = function getPointsFromBasicRect(_ref10) {
      var height = _ref10.height,
          width = _ref10.width,
          x = _ref10.x,
          y = _ref10.y;
      return [{
        x: x,
        y: y,
        moveTo: true
      }, {
        x: x + width,
        y: y
      }, {
        x: x + width,
        y: y + height
      }, {
        x: x,
        y: y + height
      }, {
        x: x,
        y: y
      }];
    };

    var getPointsFromRectWithCornerRadius = function getPointsFromRectWithCornerRadius(_ref11) {
      var height = _ref11.height,
          rx = _ref11.rx,
          ry = _ref11.ry,
          width = _ref11.width,
          x = _ref11.x,
          y = _ref11.y;
      var curve = {
        type: 'arc',
        rx: rx,
        ry: ry,
        sweepFlag: 1
      };
      return [{
        x: x + rx,
        y: y,
        moveTo: true
      }, {
        x: x + width - rx,
        y: y
      }, {
        x: x + width,
        y: y + ry,
        curve: curve
      }, {
        x: x + width,
        y: y + height - ry
      }, {
        x: x + width - rx,
        y: y + height,
        curve: curve
      }, {
        x: x + rx,
        y: y + height
      }, {
        x: x,
        y: y + height - ry,
        curve: curve
      }, {
        x: x,
        y: y + ry
      }, {
        x: x + rx,
        y: y,
        curve: curve
      }];
    };

    var getPointsFromG = function getPointsFromG(_ref12) {
      var shapes = _ref12.shapes;
      return shapes.map(function (s) {
        return toPoints(s);
      });
    };

    exports["default"] = toPoints;
  }, {}],
  16: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
      return _typeof2(obj);
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };

    var getErrors = function getErrors(shape) {
      var rules = getRules(shape);
      var errors = [];
      rules.map(function (_ref) {
        var match = _ref.match,
            prop = _ref.prop,
            required = _ref.required,
            type = _ref.type;

        if (typeof shape[prop] === 'undefined') {
          if (required) {
            errors.push(prop + ' prop is required' + (prop === 'type' ? '' : ' on a ' + shape.type));
          }
        } else {
          if (typeof type !== 'undefined') {
            if (type === 'array') {
              if (!Array.isArray(shape[prop])) {
                errors.push(prop + ' prop must be of type array');
              }
            } else if (_typeof(shape[prop]) !== type) {
              // eslint-disable-line valid-typeof
              errors.push(prop + ' prop must be of type ' + type);
            }
          }

          if (Array.isArray(match)) {
            if (match.indexOf(shape[prop]) === -1) {
              errors.push(prop + ' prop must be one of ' + match.join(', '));
            }
          }
        }
      });

      if (shape.type === 'g' && Array.isArray(shape.shapes)) {
        var childErrors = shape.shapes.map(function (s) {
          return getErrors(s);
        });
        return [].concat.apply(errors, childErrors);
      }

      return errors;
    };

    var getRules = function getRules(shape) {
      var rules = [{
        match: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect', 'g'],
        prop: 'type',
        required: true,
        type: 'string'
      }];

      switch (shape.type) {
        case 'circle':
          rules.push({
            prop: 'cx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'cy',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'r',
            required: true,
            type: 'number'
          });
          break;

        case 'ellipse':
          rules.push({
            prop: 'cx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'cy',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'rx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'ry',
            required: true,
            type: 'number'
          });
          break;

        case 'line':
          rules.push({
            prop: 'x1',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'x2',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y1',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y2',
            required: true,
            type: 'number'
          });
          break;

        case 'path':
          rules.push({
            prop: 'd',
            required: true,
            type: 'string'
          });
          break;

        case 'polygon':
        case 'polyline':
          rules.push({
            prop: 'points',
            required: true,
            type: 'string'
          });
          break;

        case 'rect':
          rules.push({
            prop: 'height',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'rx',
            type: 'number'
          });
          rules.push({
            prop: 'ry',
            type: 'number'
          });
          rules.push({
            prop: 'width',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'x',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y',
            required: true,
            type: 'number'
          });
          break;

        case 'g':
          rules.push({
            prop: 'shapes',
            required: true,
            type: 'array'
          });
          break;
      }

      return rules;
    };

    var valid = function valid(shape) {
      var errors = getErrors(shape);
      return {
        errors: errors,
        valid: errors.length === 0
      };
    };

    exports["default"] = valid;
  }, {}],
  17: [function (require, module, exports) {
    'use strict';

    module.exports = TinyQueue;
    module.exports["default"] = TinyQueue;

    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;

      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
          this._down(i);
        }
      }
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }

    TinyQueue.prototype = {
      push: function push(item) {
        this.data.push(item);
        this.length++;

        this._up(this.length - 1);
      },
      pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
          this.data[0] = this.data[this.length];

          this._down(0);
        }

        this.data.pop();
        return top;
      },
      peek: function peek() {
        return this.data[0];
      },
      _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }

        data[pos] = item;
      },
      _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];

          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }

          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }

        data[pos] = item;
      }
    };
  }, {}],
  18: [function (require, module, exports) {
    ;

    (function inject(clean, precision, undef) {
      var isArray = function isArray(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };

      var defined = function defined(a) {
        return a !== undef;
      };

      function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
          return new Vec2(x, y);
        }

        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else if ('object' === _typeof2(x) && x) {
          y = x.y;
          x = x.x;
        }

        this.x = Vec2.clean(x || 0);
        this.y = Vec2.clean(y || 0);
      }

      Vec2.prototype = {
        change: function change(fn) {
          if (typeof fn === 'function') {
            if (this.observers) {
              this.observers.push(fn);
            } else {
              this.observers = [fn];
            }
          } else if (this.observers && this.observers.length) {
            for (var i = this.observers.length - 1; i >= 0; i--) {
              this.observers[i](this, fn);
            }
          }

          return this;
        },
        ignore: function ignore(fn) {
          if (this.observers) {
            if (!fn) {
              this.observers = [];
            } else {
              var o = this.observers,
                  l = o.length;

              while (l--) {
                o[l] === fn && o.splice(l, 1);
              }
            }
          }

          return this;
        },
        // set x and y
        set: function set(x, y, notify) {
          if ('number' != typeof x) {
            notify = y;
            y = x.y;
            x = x.x;
          }

          if (this.x === x && this.y === y) {
            return this;
          }

          var orig = null;

          if (notify !== false && this.observers && this.observers.length) {
            orig = this.clone();
          }

          this.x = Vec2.clean(x);
          this.y = Vec2.clean(y);

          if (notify !== false) {
            return this.change(orig);
          }
        },
        // reset x and y to zero
        zero: function zero() {
          return this.set(0, 0);
        },
        // return a new vector with the same component values
        // as this one
        clone: function clone() {
          return new this.constructor(this.x, this.y);
        },
        // negate the values of this vector
        negate: function negate(returnNew) {
          if (returnNew) {
            return new this.constructor(-this.x, -this.y);
          } else {
            return this.set(-this.x, -this.y);
          }
        },
        // Add the incoming `vec2` vector to this vector
        add: function add(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x += this.x;
          y += this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Subtract the incoming `vec2` from this vector
        subtract: function subtract(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x = this.x - x;
          y = this.y - y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Multiply this vector by the incoming `vec2`
        multiply: function multiply(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          x *= this.x;
          y *= this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            return new this.constructor(x, y);
          }
        },
        // Rotate this vector. Accepts a `Rotation` or angle in radians.
        //
        // Passing a truthy `inverse` will cause the rotation to
        // be reversed.
        //
        // If `returnNew` is truthy, a new
        // `Vec2` will be created with the values resulting from
        // the rotation. Otherwise the rotation will be applied
        // to this vector directly, and this vector will be returned.
        rotate: function rotate(r, inverse, returnNew) {
          var x = this.x,
              y = this.y,
              cos = Math.cos(r),
              sin = Math.sin(r),
              rx,
              ry;
          inverse = inverse ? -1 : 1;
          rx = cos * x - inverse * sin * y;
          ry = inverse * sin * x + cos * y;

          if (returnNew) {
            return new this.constructor(rx, ry);
          } else {
            return this.set(rx, ry);
          }
        },
        // Calculate the length of this vector
        length: function length() {
          var x = this.x,
              y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
        lengthSquared: function lengthSquared() {
          var x = this.x,
              y = this.y;
          return x * x + y * y;
        },
        // Return the distance betwen this `Vec2` and the incoming vec2 vector
        // and return a scalar
        distance: function distance(vec2) {
          var x = this.x - vec2.x;
          var y = this.y - vec2.y;
          return Math.sqrt(x * x + y * y);
        },
        // Given Array of Vec2, find closest to this Vec2.
        nearest: function nearest(others) {
          var shortestDistance = Number.MAX_VALUE,
              nearest = null,
              currentDistance;

          for (var i = others.length - 1; i >= 0; i--) {
            currentDistance = this.distance(others[i]);

            if (currentDistance <= shortestDistance) {
              shortestDistance = currentDistance;
              nearest = others[i];
            }
          }

          return nearest;
        },
        // Convert this vector into a unit vector.
        // Returns the length.
        normalize: function normalize(returnNew) {
          var length = this.length(); // Collect a ratio to shrink the x and y coords

          var invertedLength = length < Number.MIN_VALUE ? 0 : 1 / length;

          if (!returnNew) {
            // Convert the coords to be greater than zero
            // but smaller than or equal to 1.0
            return this.set(this.x * invertedLength, this.y * invertedLength);
          } else {
            return new this.constructor(this.x * invertedLength, this.y * invertedLength);
          }
        },
        // Determine if another `Vec2`'s components match this one's
        // also accepts 2 scalars
        equal: function equal(v, w) {
          if (typeof v != 'number') {
            if (isArray(v)) {
              w = v[1];
              v = v[0];
            } else {
              w = v.y;
              v = v.x;
            }
          }

          return Vec2.clean(v) === this.x && Vec2.clean(w) === this.y;
        },
        // Return a new `Vec2` that contains the absolute value of
        // each of this vector's parts
        abs: function abs(returnNew) {
          var x = Math.abs(this.x),
              y = Math.abs(this.y);

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the smallest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        min: function min(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx < vx ? tx : vx,
              y = ty < vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the largest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        max: function max(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx > vx ? tx : vx,
              y = ty > vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Clamp values into a range.
        // If this vector's values are lower than the `low`'s
        // values, then raise them.  If they are higher than
        // `high`'s then lower them.
        //
        // Passing returnNew as true will cause a new Vec2 to be
        // returned.  Otherwise, this vector's values will be clamped
        clamp: function clamp(low, high, returnNew) {
          var ret = this.min(high, true).max(low);

          if (returnNew) {
            return ret;
          } else {
            return this.set(ret.x, ret.y);
          }
        },
        // Perform linear interpolation between two vectors
        // amount is a decimal between 0 and 1
        lerp: function lerp(vec, amount, returnNew) {
          return this.add(vec.subtract(this, true).multiply(amount), returnNew);
        },
        // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        skew: function skew(returnNew) {
          if (!returnNew) {
            return this.set(-this.y, this.x);
          } else {
            return new this.constructor(-this.y, this.x);
          }
        },
        // calculate the dot product between
        // this vector and the incoming
        dot: function dot(b) {
          return Vec2.clean(this.x * b.x + b.y * this.y);
        },
        // calculate the perpendicular dot product between
        // this vector and the incoming
        perpDot: function perpDot(b) {
          return Vec2.clean(this.x * b.y - this.y * b.x);
        },
        // Determine the angle between two vec2s
        angleTo: function angleTo(vec) {
          return Math.atan2(this.perpDot(vec), this.dot(vec));
        },
        // Divide this vector's components by a scalar
        divide: function divide(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          if (x === 0 || y === 0) {
            throw new Error('division by zero');
          }

          if (isNaN(x) || isNaN(y)) {
            throw new Error('NaN detected');
          }

          if (returnNew) {
            return new this.constructor(this.x / x, this.y / y);
          }

          return this.set(this.x / x, this.y / y);
        },
        isPointOnLine: function isPointOnLine(start, end) {
          return (start.y - this.y) * (start.x - end.x) === (start.y - end.y) * (start.x - this.x);
        },
        toArray: function toArray() {
          return [this.x, this.y];
        },
        fromArray: function fromArray(array) {
          return this.set(array[0], array[1]);
        },
        toJSON: function toJSON() {
          return {
            x: this.x,
            y: this.y
          };
        },
        toString: function toString() {
          return '(' + this.x + ', ' + this.y + ')';
        },
        constructor: Vec2
      };

      Vec2.fromArray = function (array, ctor) {
        return new (ctor || Vec2)(array[0], array[1]);
      }; // Floating point stability


      Vec2.precision = precision || 8;
      var p = Math.pow(10, Vec2.precision);

      Vec2.clean = clean || function (val) {
        if (isNaN(val)) {
          throw new Error('NaN detected');
        }

        if (!isFinite(val)) {
          throw new Error('Infinity detected');
        }

        if (Math.round(val) === val) {
          return val;
        }

        return Math.round(val * p) / p;
      };

      Vec2.inject = inject;

      if (!clean) {
        Vec2.fast = inject(function (k) {
          return k;
        }); // Expose, but also allow creating a fresh Vec2 subclass.

        if (typeof module !== 'undefined' && _typeof2(module.exports) == 'object') {
          module.exports = Vec2;
        } else {
          window.Vec2 = window.Vec2 || Vec2;
        }
      }

      return Vec2;
    })();
  }, {}],
  19: [function (require, module, exports) {
    /*
    =============================================================================
      ParametersPanel class
    =============================================================================
    */
    var ParametersPanel = /*#__PURE__*/function () {
      function ParametersPanel(world) {
        _classCallCheck(this, ParametersPanel);

        this.world = world; // Get all DOM elements

        this.getElements(); // Set values of all ranges from World settings

        this.loadInitialValues(); // Set up listeners to bind ranges/checkboxes to World parameters
        // Set up listeners to change value spans for each range

        this.setupValueChangeListeners();
      }

      _createClass(ParametersPanel, [{
        key: "getElements",
        value: function getElements() {
          // Min distance
          this.minDistanceRange = document.querySelector('.parameters-content #min-distance');
          this.minDistanceValue = document.querySelector('.parameters-content #min-distance + .value'); // Max distance

          this.maxDistanceRange = document.querySelector('.parameters-content #max-distance');
          this.maxDistanceValue = document.querySelector('.parameters-content #max-distance + .value'); // Repulsion radius

          this.repulsionRadiusRange = document.querySelector('.parameters-content #repulsion-radius');
          this.repulsionRadiusValue = document.querySelector('.parameters-content #repulsion-radius + .value'); // ---
          // Attraction force

          this.attractionForceRange = document.querySelector('.parameters-content #attraction-force');
          this.attractionForceValue = document.querySelector('.parameters-content #attraction-force + .value'); // Repulsion force

          this.repulsionForceRange = document.querySelector('.parameters-content #repulsion-force');
          this.repulsionForceValue = document.querySelector('.parameters-content #repulsion-force + .value'); // Alignment force

          this.alignmentForceRange = document.querySelector('.parameters-content #alignment-force');
          this.alignmentForceValue = document.querySelector('.parameters-content #alignment-force + .value'); // ---
          // Checkboxes

          this.drawNodesCheckbox = document.querySelector('.parameters-content #draw-nodes');
          this.fillModeCheckbox = document.querySelector('.parameters-content #fill-mode');
          this.debugModeCheckbox = document.querySelector('.parameters-content #debug-mode');
          this.invertedColorsCheckbox = document.querySelector('.parameters-content #inverted-colors');
          this.traceModeCheckbox = document.querySelector('.parameters-content #trace-mode'); // ---
          // Draw history checkbox and ranges

          this.drawHistoryCheckbox = document.querySelector('.parameters-content #draw-history');
          this.historyIntervalRange = document.querySelector('.parameters-content #history-capture-interval');
          this.historyIntervalValue = document.querySelector('.parameters-content #history-capture-interval + .value');
          this.maxHistoryRange = document.querySelector('.parameters-content #max-history-size');
          this.maxHistoryValue = document.querySelector('.parameters-content #max-history-size + .value'); // ---
          // Brownian motion checkbox and range

          this.brownianMotionCheckbox = document.querySelector('.parameters-content #use-brownian-motion');
          this.brownianMotionRange = document.querySelector('.parameters-content #brownian-motion-range');
          this.brownianMotionValue = document.querySelector('.parameters-content #brownian-motion-range + .value');
        }
      }, {
        key: "loadInitialValues",
        value: function loadInitialValues() {
          // Min distance
          this.minDistanceRange.value = this.world.settings.MinDistance;
          this.minDistanceValue.innerHTML = this.world.settings.MinDistance; // Max distance

          this.maxDistanceRange.value = this.world.settings.MaxDistance;
          this.maxDistanceValue.innerHTML = this.world.settings.MaxDistance; // Repulsion radius

          this.repulsionRadiusRange.value = this.world.settings.RepulsionRadius;
          this.repulsionRadiusValue.innerHTML = this.world.settings.RepulsionRadius; // ---
          // Attraction force

          this.attractionForceRange.value = this.world.settings.AttractionForce;
          this.attractionForceValue.innerHTML = this.world.settings.AttractionForce; // Repulsion force

          this.repulsionForceRange.value = this.world.settings.RepulsionForce;
          this.repulsionForceValue.innerHTML = this.world.settings.RepulsionForce; // Alignment force

          this.alignmentForceRange.value = this.world.settings.AlignmentForce;
          this.alignmentForceValue.innerHTML = this.world.settings.AlignmentForce; // ---

          this.drawNodesCheckbox.checked = this.world.settings.DrawNodes;
          this.fillModeCheckbox.checked = this.world.settings.FillMode;
          this.debugModeCheckbox.checked = this.world.settings.DebugMode;
          this.invertedColorsCheckbox.checked = this.world.settings.InvertedColors;
          this.traceModeCheckbox.checked = this.world.settings.TraceMode; // ---

          this.drawHistoryCheckbox.checked = this.world.settings.DrawHistory;
          this.historyIntervalRange.value = this.world.settings.HistoryCaptureInterval;
          this.historyIntervalValue.innerHTML = this.world.settings.HistoryCaptureInterval;
          this.maxHistoryRange.value = this.world.settings.MaxHistorySize;
          this.maxHistoryValue.innerHTML = this.world.settings.MaxHistorySize; // ---

          this.brownianMotionCheckbox.checked = this.world.settings.UseBrownianMotion;
          this.brownianMotionRange.value = this.world.settings.BrownianMotionRange;
          this.brownianMotionValue.innerHTML = this.world.settings.BrownianMotionRange;
        }
      }, {
        key: "setupValueChangeListeners",
        value: function setupValueChangeListeners() {
          this.minDistanceRange.addEventListener('input', this.minDistanceChangeHandler.bind(this));
          this.maxDistanceRange.addEventListener('input', this.maxDistanceChangeHandler.bind(this));
          this.repulsionRadiusRange.addEventListener('input', this.repulsionRadiusChangeHandler.bind(this));
          this.attractionForceRange.addEventListener('input', this.attractionForceChangeHandler.bind(this));
          this.repulsionForceRange.addEventListener('input', this.repulsionForceChangeHandler.bind(this));
          this.alignmentForceRange.addEventListener('input', this.alignmentForceChangeHandler.bind(this));
          this.drawNodesCheckbox.addEventListener('change', this.drawNodesChangeHandler.bind(this));
          this.fillModeCheckbox.addEventListener('change', this.fillModeChangeHandler.bind(this));
          this.debugModeCheckbox.addEventListener('change', this.debugModeChangeHandler.bind(this));
          this.invertedColorsCheckbox.addEventListener('change', this.invertedColorsChangeHandler.bind(this));
          this.traceModeCheckbox.addEventListener('change', this.traceModeChangeHandler.bind(this));
          this.drawHistoryCheckbox.addEventListener('change', this.drawHistoryChangeHandler.bind(this));
          this.historyIntervalRange.addEventListener('input', this.historyIntervalChangeHandler.bind(this));
          this.maxHistoryRange.addEventListener('input', this.maxHistoryChangeHandler.bind(this));
          this.brownianMotionCheckbox.addEventListener('change', this.brownianMotionChangeHandler.bind(this));
          this.brownianMotionRange.addEventListener('input', this.brownianMotionRangeChangeHandler.bind(this));
        }
      }, {
        key: "minDistanceChangeHandler",
        value: function minDistanceChangeHandler(e) {
          this.minDistanceValue.innerHTML = e.target.value;
          this.world.setMinDistance(e.target.value);
        }
      }, {
        key: "maxDistanceChangeHandler",
        value: function maxDistanceChangeHandler(e) {
          this.maxDistanceValue.innerHTML = e.target.value;
          this.world.setMaxDistance(e.target.value);
        }
      }, {
        key: "repulsionRadiusChangeHandler",
        value: function repulsionRadiusChangeHandler(e) {
          this.repulsionRadiusValue.innerHTML = e.target.value;
          this.world.setRepulsionRadius(e.target.value);
        }
      }, {
        key: "attractionForceChangeHandler",
        value: function attractionForceChangeHandler(e) {
          this.attractionForceValue.innerHTML = e.target.value;
          this.world.setAttractionForce(e.target.value);
        }
      }, {
        key: "repulsionForceChangeHandler",
        value: function repulsionForceChangeHandler(e) {
          this.repulsionForceValue.innerHTML = e.target.value;
          this.world.setRepulsionForce(e.target.value);
        }
      }, {
        key: "alignmentForceChangeHandler",
        value: function alignmentForceChangeHandler(e) {
          this.alignmentForceValue.innerHTML = e.target.value;
          this.world.setAlignmentForce(e.target.value);
        }
      }, {
        key: "drawNodesChangeHandler",
        value: function drawNodesChangeHandler(e) {
          this.world.setDrawNodes(e.target.checked);
        }
      }, {
        key: "fillModeChangeHandler",
        value: function fillModeChangeHandler(e) {
          this.world.setFillMode(e.target.checked);
        }
      }, {
        key: "debugModeChangeHandler",
        value: function debugModeChangeHandler(e) {
          this.world.setDebugMode(e.target.checked);
        }
      }, {
        key: "invertedColorsChangeHandler",
        value: function invertedColorsChangeHandler(e) {
          this.world.setInvertedColors(e.target.checked);
          document.querySelector('body').classList.toggle('is-inverted');
        }
      }, {
        key: "traceModeChangeHandler",
        value: function traceModeChangeHandler(e) {
          this.world.setTraceMode(e.target.checked);
        }
      }, {
        key: "drawHistoryChangeHandler",
        value: function drawHistoryChangeHandler(e) {
          this.world.setDrawHistory(e.target.checked);
        }
      }, {
        key: "historyIntervalChangeHandler",
        value: function historyIntervalChangeHandler(e) {
          this.historyIntervalValue.innerHTML = e.target.value;
        }
      }, {
        key: "maxHistoryChangeHandler",
        value: function maxHistoryChangeHandler(e) {
          this.maxHistoryValue.innerHTML = e.target.value;
        }
      }, {
        key: "brownianMotionChangeHandler",
        value: function brownianMotionChangeHandler(e) {
          this.world.setBrownianMotion(e.target.checked);
        }
      }, {
        key: "brownianMotionRangeChangeHandler",
        value: function brownianMotionRangeChangeHandler(e) {
          this.brownianMotionValue.innerHTML = e.target.value;
        }
      }]);

      return ParametersPanel;
    }();

    module.exports = ParametersPanel;
  }, {}],
  20: [function (require, module, exports) {
    module.exports = {
      MinDistance: 2,
      MaxDistance: 5,
      RepulsionRadius: 15,
      AttractionForce: .2,
      RepulsionForce: .6,
      AlignmentForce: .55,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      InvertedColors: false,
      DebugMode: false,
      FillMode: false,
      DrawHistory: false,
      ShowBounds: true
    };
  }, {}],
  21: [function (require, module, exports) {
    var Node = require('../../../core/Node'),
        Path = require('../../../core/Path'),
        World = require('../../../core/World'),
        SVGLoader = require('../../../core/SVGLoader'),
        Settings = require('./Settings'),
        ParametersPanel = require('./ParametersPanel');

    var world,
        path,
        nodes = [];
    var FREEHAND = 0,
        RECTANGLE = 1,
        CIRCLE = 2;
    var activeTool = FREEHAND;
    var distanceToClose = 10;
    var startX, startY, endX, endY, deltaX, deltaY;
    var allButtonEls = document.querySelectorAll('button'),
        svgImportInputEl = document.querySelector('.svgImportInput'),
        playButtonEl = document.querySelector('.play');
    var modalEl = document.querySelector('.modal'),
        triggeringEl,
        firstFocusableElement,
        lastFocusableElement;
    /*
    =============================================================================
      p5.js sketch
    =============================================================================
    */

    var sketch = function sketch(p5) {
      // Setup -------------------------------------------------------------
      p5.setup = function () {
        p5.createCanvas(window.innerWidth, window.innerHeight);
        p5.colorMode(p5.HSB, 255);
        p5.rectMode(p5.CENTER);
        p5.smooth(); // Set up and start the simulation

        world = new World(p5, Settings);
        world.pause(); // Set up the Parameters window

        var paramPanel = new ParametersPanel(world); // Left menu ----------------------
        // Drawing tools

        document.querySelector('.freehand').addEventListener('click', handleToolClick);
        document.querySelector('.rectangle').addEventListener('click', handleToolClick);
        document.querySelector('.circle').addEventListener('click', handleToolClick); // Import, export, and clear

        document.querySelector('.import').addEventListener('click', openFileImport);
        document.querySelector('.reset').addEventListener('click', clearPaths);
        document.querySelector('.export').addEventListener('click', exportSVG); // Center controls ----------------

        document.querySelector('.play').addEventListener('click', togglePause); // Right menu ---------------------

        document.querySelector('.keyboard').addEventListener('click', toggleKeyboardControls);
        document.querySelector('.about').addEventListener('click', toggleAbout);
        document.querySelector('.parameters').addEventListener('click', toggleParameters); // Other functions ----------------

        document.querySelector('.svgImportInput').addEventListener('change', importSVG);
        document.querySelector('.start').addEventListener('click', closeModal);
      }; // Draw ---------------------------------------------------------------


      p5.draw = function () {
        if (!world.paused) {
          world.iterate();
          world.draw();
        }
      };
      /*
      =============================================================================
        Custom functions
      =============================================================================
      */


      function setActiveTool(tool) {
        var _iterator40 = _createForOfIteratorHelper(allButtonEls),
            _step40;

        try {
          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
            var button = _step40.value;
            button.removeAttribute('aria-current');
          }
        } catch (err) {
          _iterator40.e(err);
        } finally {
          _iterator40.f();
        }

        switch (tool) {
          case FREEHAND:
            document.querySelector('.freehand').setAttribute('aria-current', true);
            break;

          case RECTANGLE:
            document.querySelector('.rectangle').setAttribute('aria-current', true);
            break;

          case CIRCLE:
            document.querySelector('.circle').setAttribute('aria-current', true);
            break;
        }

        activeTool = tool;
      } // Set active tool based on which tool icon was clicked


      function handleToolClick(e) {
        if (e.target.classList.contains('freehand')) {
          setActiveTool(FREEHAND);
        } else if (e.target.classList.contains('rectangle')) {
          setActiveTool(RECTANGLE);
        } else if (e.target.classList.contains('circle')) {
          setActiveTool(CIRCLE);
        }
      } // Import SVG - open file input dialog


      function openFileImport() {
        svgImportInputEl.click();
      } // Eraser - clear all paths from the world


      function clearPaths() {
        world.clearPaths();
        world.drawBackground();
      } // Download SVG - export world contents as SVG


      function exportSVG() {
        world["export"]();
      } // Play button - toggle pause/unpause of world


      function togglePause() {
        world.togglePause();
        var icon = playButtonEl.querySelector('.icon');
        var text = playButtonEl.querySelector('.text');

        if (world.paused) {
          icon.classList.remove('fa-pause');
          icon.classList.add('fa-play');
          text.innerHTML = 'Play';
        } else {
          icon.classList.remove('fa-play');
          icon.classList.add('fa-pause');
          text.innerHTML = 'Pause';
        }
      } // Keyboard icon - toggle keyboard controls modal window


      function toggleKeyboardControls() {
        triggeringEl = document.querySelector('.keyboard');
        openModal('keyboard-controls');
      } // Question mark icon - toggle 'about' modal window


      function toggleAbout() {
        triggeringEl = document.querySelector('.about');
        openModal('about');
      } // Sliders icon - toggle parameters modal window


      function toggleParameters() {
        triggeringEl = document.querySelector('.parameters');
        openModal('parameters');
      }

      function openModal(modal) {
        var allContentEls = modalEl.querySelectorAll('.modal-content > div:not(.close)');

        var _iterator41 = _createForOfIteratorHelper(allContentEls),
            _step41;

        try {
          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
            var contentEl = _step41.value;
            contentEl.classList.add('is-hidden');
          }
        } catch (err) {
          _iterator41.e(err);
        } finally {
          _iterator41.f();
        }

        modalEl.querySelector('.' + modal + '-content').classList.remove('is-hidden');
        modalEl.classList.add('is-visible');
        modalEl.querySelector('.modal-backdrop').addEventListener('click', closeModal);
        modalEl.querySelector('.close').addEventListener('click', closeModal);
        modalEl.addEventListener('keydown', function (e) {
          if (e.key == 'Escape') {
            closeModal();
          }

          if (modal === 'keyboard-controls') {
            if (e.key == 'Tab') {
              e.preventDefault();
            }
          } else {
            firstFocusableElement = modalEl.querySelector('.first-focusable-element');
            lastFocusableElement = modalEl.querySelector('.' + modal + '-content').querySelector('.last-focusable-element');

            if (e.target == firstFocusableElement && e.key == 'Tab' && e.shiftKey) {
              e.preventDefault();
              lastFocusableElement.focus();
            } else if (e.target == lastFocusableElement && e.key == 'Tab' && !e.shiftKey) {
              e.preventDefault();
              firstFocusableElement.focus();
            }
          }
        });
        modalEl.querySelector('.close').focus();
      }

      function closeModal() {
        modalEl.classList.remove('is-visible');
        triggeringEl.focus();
      } // Parse SVG file from user input and add to World


      function importSVG() {
        var file = this.files[0];

        if (file.type === 'image/svg+xml') {
          var reader = new FileReader(); // When a file is loaded, convert it from a raw text string to a DOM tree, then parse it for Paths and add to World

          reader.onload = function () {
            var parser = new DOMParser();
            var svgNode = parser.parseFromString(reader.result, "image/svg+xml");
            var paths = SVGLoader.load(p5, svgNode, Settings);
            world.addPaths(paths);
            world.draw();
          }; // Read the contents of the uploaded file as a raw text string


          reader.readAsText(file);
        } // Blur the focus on the button so it isn't accidentally retriggered on 'Space'


        document.querySelector('.import').blur();
      }
      /*
      =============================================================================
        Mouse handlers
      =============================================================================
      */


      p5.mousePressed = function () {
        switch (activeTool) {
          // Rectangle tool -----------------------------------
          case RECTANGLE:
          case CIRCLE:
            startX = p5.mouseX;
            startY = p5.mouseY;
            break;
        }
      };

      p5.mouseReleased = function () {
        switch (activeTool) {
          // Freehand tool ------------------------------------
          case FREEHAND:
            if (p5.mouseButton == p5.LEFT) {
              if (nodes.length == 0) {
                return;
              }

              var isClosed = false,
                  firstNode = nodes[0],
                  lastNode = nodes[nodes.length - 1]; // If end point is very close to starting point, make the path closed

              if (lastNode.distance(firstNode) <= distanceToClose) {
                isClosed = true;
              } // Create and add Path to the World


              path = new Path(p5, nodes, Settings, isClosed);
              world.addPath(path);
              nodes = [];
            }

            break;
          // Rectangle tool -----------------------------------

          case RECTANGLE:
            endX = p5.mouseX;
            endY = p5.mouseY;
            nodes.push(new Node(p5, startX, startY, Settings)); // top left

            nodes.push(new Node(p5, endX, startY, Settings)); // top right

            nodes.push(new Node(p5, endX, endY, Settings)); // bottom right

            nodes.push(new Node(p5, startX, endY, Settings)); // bottom left

            path = new Path(p5, nodes, Settings, true);
            world.addPath(path);
            nodes = [];
            break;
          // Circle tool --------------------------------------

          case CIRCLE:
            endX = p5.mouseX;
            endY = p5.mouseY;
            deltaX = endX - startX;
            deltaY = endY - startY;

            for (var i = 0; i < 360; i++) {
              nodes.push(new Node(p5, startX + deltaX / 2 + deltaX / 2 * Math.cos(i * Math.PI / 180), startY + deltaY / 2 + deltaY / 2 * Math.sin(i * Math.PI / 180), Settings));
            }

            path = new Path(p5, nodes, Settings, true);
            world.addPath(path);
            nodes = [];
            break;
        }

        world.draw();
      };

      p5.mouseDragged = function () {
        if (!world.paused) {
          world.pause();
        }

        world.draw();

        switch (activeTool) {
          // Freehand tool ------------------------------------
          case FREEHAND:
            if (p5.mouseButton == p5.LEFT) {
              nodes.push(new Node(p5, p5.mouseX, p5.mouseY, Settings));

              if (nodes.length > 0) {
                var _iterator42 = _createForOfIteratorHelper(nodes.entries()),
                    _step42;

                try {
                  for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
                    var _step42$value = _slicedToArray(_step42.value, 2),
                        index = _step42$value[0],
                        node = _step42$value[1];

                    if (index > 0) {
                      p5.stroke(0);
                      p5.line(nodes[index - 1].x, nodes[index - 1].y, node.x, node.y);
                    }
                  }
                } catch (err) {
                  _iterator42.e(err);
                } finally {
                  _iterator42.f();
                }
              }

              var firstNode = nodes[0],
                  lastNode = nodes[nodes.length - 1]; // If current point is very near the starting point, highlight the starting point to indicate that the path will close

              if (lastNode.distance(firstNode) <= distanceToClose) {
                p5.fill(150);
                p5.noStroke();
                p5.ellipseMode(p5.CENTER);
                p5.ellipse(nodes[0].x, nodes[0].y, distanceToClose * 2);
              }
            }

            break;
          // Rectangle tool -----------------------------------

          case RECTANGLE:
            if (p5.mouseButton == p5.LEFT) {
              p5.stroke(0);
              p5.line(startX, startY, p5.mouseX, startY); // top

              p5.line(p5.mouseX, startY, p5.mouseX, p5.mouseY); // right

              p5.line(p5.mouseX, p5.mouseY, startX, p5.mouseY); // bottom

              p5.line(startX, p5.mouseY, startX, startY); // left
            }

            break;
          // Circle tool --------------------------------------

          case CIRCLE:
            if (p5.mouseButton == p5.LEFT && startX != undefined && startY != undefined) {
              p5.stroke(0);
              p5.noFill();
              p5.ellipseMode(p5.CORNERS);
              p5.ellipse(startX, startY, p5.mouseX, p5.mouseY);
            }

        }
      };
      /*
      =============================================================================
        Key handler
      =============================================================================
      */


      p5.keyReleased = function () {
        switch (p5.key) {
          // Toggle trace mode with 't'
          case 't':
            world.toggleTraceMode();
            break;
          // Toggle drawing of nodes with 'n'

          case 'n':
            world.toggleDrawNodes();
            break;
          // Reset simulation with current parameters with 'r'

          case 'r':
            world.clearPaths();
            world.drawBackground();
            break;
          // Toggle pause with Space

          case ' ':
            togglePause();
            break;
          // Invert colors with 'i'

          case 'i':
            world.toggleInvertedColors();
            break;
          // Toggle debug mode with 'd'

          case 'd':
            world.toggleDebugMode();
            break;
          // Toggle fill for all shapes with 'f'

          case 'f':
            world.toggleFillMode();
            break;
          // Toggle path history with 'h'

          case 'h':
            world.toggleDrawHistory();
            break;
          // Export SVG with 's'

          case 's':
            world["export"]();
            break;
          // Toggle visibility of all bounds for all paths with 'b'

          case 'b':
            world.toggleDrawBounds();
            break;
        }
      };
    }; // Launch the sketch using p5js in instantiated mode


    new p5(sketch);
  }, {
    "../../../core/Node": 3,
    "../../../core/Path": 4,
    "../../../core/SVGLoader": 5,
    "../../../core/World": 6,
    "./ParametersPanel": 19,
    "./Settings": 20
  }]
}, {}, [21]);